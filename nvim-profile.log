SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    1              0.000030 if exists("did_load_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000004 let did_load_ftplugin = 1
                            
    1              0.000007 augroup filetypeplugin
    1              0.000008   au FileType * call s:LoadFTPlugin()
                            
    1              0.000003   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
                                  endfor
                                endif
                              endfunc
    1              0.000002 augroup END

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/indent.vim
Sourced 1 time
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
    1              0.000016 if exists("did_indent_on")
                              finish
    1              0.000001 endif
    1              0.000005 let did_indent_on = 1
                            
    1              0.000004 augroup filetypeindent
    1              0.000008   au FileType * call s:LoadIndent()
    1              0.000004   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
                                    exe $'runtime! indent/{name}[.]{{vim,lua}}'
                                  endfor
                                endif
                              endfunc
    1              0.000003 augroup END

SCRIPT  /Users/albertos/.config/nvim/init.lua
Sourced 1 time
Total time:   0.383068
 Self time:   0.314000

count  total (s)   self (s)
  155              0.748397 ---@diagnostic disable: missing-fields
   10              0.000108 ---
    7              0.000070 
    7              0.000048 -- enabled functionality things...
    4              0.000005 _G.enable_auto_pair = false
    2              0.000004 _G.enable_autocompletion = false
    1              0.000004 _G.enable_color_picker = false
                            _G.enable_syntax_highlight = true
                            _G.enable_line_wrap = false
                            _G.enable_smooth_scroll = false
                            _G.enable_simple_colors = false
                            _G.enable_zen_mode = false
                            _G.grug_instance_global = "grug-instance-global"
                            _G.grug_instance_local = "grug-instance-local"
                            _G.hide_all = false
                            _G.show_cursorline = true
                            _G.show_diagnostics = false
                            _G.show_diagnostics_text = false
                            _G.show_diagnostics_underline = false
                            _G.show_gitblame = false
                            _G.show_gitsigns = false
                            _G.show_illuminate = true
                            _G.show_indent_lines = false
                            _G.show_inlay_hints = false
                            _G.show_invisible_chars = false
                            _G.show_scrollbar = true
                            _G.show_statusline = false
                            _G.show_treesitter_context = false
                            _G.show_vimade = false
                            _G.show_winbar = true
                            
                            if vim.loader then
                              vim.loader.enable()
                            end
                            
                            local use_alternate_directory = false
                            
                            local root = vim.fn.stdpath("data")
                            if use_alternate_directory then
                              root = vim.fn.expand("~/dev")
                            end
                            
                            local lazyroot = root .. "/lazy/"
                            local lazypath = lazyroot .. "lazy.nvim"
                            if not (vim.uv or vim.loop).fs_stat(lazypath) then
                              local lazyrepo = "https://github.com/folke/lazy.nvim.git"
                              local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
                              if vim.v.shell_error ~= 0 then
                                vim.api.nvim_echo({
                                  { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
                                  { out,                            "WarningMsg" },
                                  { "\nPress any key to exit..." },
                                }, true, {})
                                vim.fn.getchar()
                                os.exit(1)
                              end
                            end
                            vim.opt.rtp:prepend(lazypath)
                            
                            vim.g.mapleader = ","
                            vim.g.maplocalleader = " "
                            
                            vim.g.loaded_node_provider = 0
                            vim.g.loaded_perl_provider = 0
                            vim.g.loaded_python_provider = 0
                            vim.g.loaded_ruby_provider = 0
                            
                            vim.opt.breakindent = true
                            vim.opt.cmdheight = 0
                            vim.opt.cursorline = _G.show_cursorline
                            vim.opt.diffopt = "internal,filler,closeoff,linematch:60"
                            vim.opt.expandtab = true
                            vim.opt.fillchars = [[eob: ,fold: ,foldopen:,foldsep: ,foldclose:]] --   ||   ||  
                            
                            vim.opt.foldcolumn = "0" -- "0" to hide folds. "1" to show.
                            vim.opt.foldenable = true
                            vim.opt.foldlevel = 99
                            vim.opt.foldlevelstart = 99
                            -- vim.opt.foldmethod = "expr"
                            -- vim.opt.foldexpr = "v:lua.vim.lsp.foldexpr()"
                            
                            vim.opt.modeline = false --- may want these some day but having issues with markdown files
                            vim.opt.guicursor =
                            "n-v-c:blocki,i-ci-ve:ver25,r-cr:hor20,o:hor50,a:blinkwait500-blinkoff250-blinkon250,sm:block-blinkwait500-blinkoff250-blinkon250"
                            vim.opt.ignorecase = true
                            vim.opt.list = show_invisible_chars
                            vim.opt.listchars = "nbsp:+,trail:·,extends:,precedes:,space:·,tab:»»" -- NOTE: tab must have 2 characters
                            vim.opt.redrawtime = 1500
                            vim.opt.scrolloff = 0
                            vim.opt.sessionoptions = "buffers,curdir,winsize,winpos" -- could include localoptions
                            vim.opt.shiftwidth = 2
                            vim.opt.showbreak = "↳  " -- slow on huge linebreaks for some reason
                            vim.opt.signcolumn = "yes"
                            vim.opt.showtabline = 1
                            vim.opt.smartcase = true
                            vim.opt.smartindent = true
                            vim.opt.splitbelow = true
                            vim.opt.splitright = true
                            vim.opt.swapfile = false
                            vim.opt.synmaxcol = 256
                            vim.opt.tabstop = 2
                            vim.opt.updatetime = 100
                            
                            -- vim.opt.statuscolumn = "%s %r %l"
                            
                            if not _G.enable_line_wrap then
                              vim.cmd("set nowrap nolinebreak")
                            else
                              vim.cmd("set wrap linebreak")
                            end
                            
                            -- line numbers FTW
                            vim.cmd("set nonu nornu")
                            
                            vim.schedule(function()
                              vim.opt.clipboard = "unnamedplus"
                            end)
                            
                            if vim.g.neovide then
                              vim.o.guifont = "JetBrainsMono Nerd Font Mono"
                              vim.g.neovide_floating_shadow = false
                              vim.g.neovide_floating_z_height = 10
                              vim.g.neovide_light_angle_degrees = 45
                              vim.g.neovide_light_radius = 5
                              -- vim.g.neovide_scroll_animation_length = 0.05
                              vim.g.neovide_position_animation_length = 0
                              vim.g.neovide_cursor_animation_length = 0.00
                              vim.g.neovide_cursor_trail_size = 0
                              vim.g.neovide_cursor_animate_in_insert_mode = false
                              vim.g.neovide_cursor_animate_command_line = false
                              vim.g.neovide_scroll_animation_far_lines = 0
                              vim.g.neovide_scroll_animation_length = 0.00
                              -- TODO: at some point add hotkeys for modifying font size.
                            end
                            
                            ---
                            --- Keymaps
                            ---
                            vim.keymap.set("n", "<esc>", ":nohl<CR>", { desc = "Clear highlight" })
                            
                            vim.keymap.set("i", "<c-l>", "<ESC>A", { desc = "Go to end of line" })
                            vim.keymap.set("i", "<c-h>", "<ESC>I", { desc = "Go to start of line" })
                            
                            vim.keymap.set("n", "z1", "<CMD>setlocal foldlevel=0<CR>", { desc = "Fold level 1" })
                            vim.keymap.set("n", "z2", "<CMD>setlocal foldlevel=1<CR>", { desc = "Fold level 2" })
                            vim.keymap.set("n", "z3", "<CMD>setlocal foldlevel=2<CR>", { desc = "Fold level 3" })
                            vim.keymap.set("n", "z4", "<CMD>setlocal foldlevel=3<CR>", { desc = "Fold level 4" })
                            vim.keymap.set("n", "z0", "<CMD>setlocal foldlevel=99<CR>", { desc = "Reset fold level" })
                            
                            vim.keymap.set("n", "j", "v:count == 0 ? 'gj' : 'j'", { expr = true })
                            vim.keymap.set("n", "k", "v:count == 0 ? 'gk' : 'k'", { expr = true })
                            
                            vim.keymap.set("n", "<ScrollWheelUp>", "<C-y>")
                            vim.keymap.set("n", "<ScrollWheelDown>", "<C-e>")
                            vim.keymap.set("i", "<ScrollWheelUp>", "<C-y>")
                            vim.keymap.set("i", "<ScrollWheelDown>", "<C-e>")
                            vim.keymap.set("v", "<ScrollWheelUp>", "<C-y>")
                            vim.keymap.set("v", "<ScrollWheelDown>", "<C-e>")
                            
                            vim.keymap.set("n", "<leader>wh", "<C-w>h", { desc = "Focus left window" })
                            vim.keymap.set("n", "<leader>wj", "<C-w>j", { desc = "Focus bottom window" })
                            vim.keymap.set("n", "<leader>wk", "<C-w>k", { desc = "Focus top window" })
                            vim.keymap.set("n", "<leader>wl", "<C-w>l", { desc = "Focus right window" })
                            
                            vim.keymap.set("n", "<leader>wo", "<C-w>o", { desc = "Close other windows" })
                            vim.keymap.set("n", "<leader>wq", "<C-w>q", { desc = "Close this window" })
                            
                            vim.keymap.set("n", "<leader>w=", "<C-w>=", { desc = "Equalize windows" })
                            vim.keymap.set("n", "<leader>ws", "<C-w>s", { desc = "Split window horizontally" })
                            vim.keymap.set("n", "<leader>wv", "<C-w>v", { desc = "Split window vertically" })
                            
                            vim.keymap.set("n", "<leader>wH", "<C-w>H", { desc = "Go to the left window" })
                            vim.keymap.set("n", "<leader>wJ", "<C-w>J", { desc = "Go to the down window" })
                            vim.keymap.set("n", "<leader>wK", "<C-w>K", { desc = "Go to the up window" })
                            vim.keymap.set("n", "<leader>wL", "<C-w>L", { desc = "Go to the right window" })
                            
                            vim.keymap.set("n", "<leader>d", "<C-d>", { desc = "Scroll down" })
                            vim.keymap.set("n", "<leader>u", "<C-u>", { desc = "Scroll up" })
                            
                            vim.keymap.set("n", "<leader>s", ":silent! w<CR>", { desc = "Save", silent = true })
                            
                            vim.keymap.set("n", "<leader>qf", ":qa!<CR>.", { desc = "Save and Quit", silent = true })
                            
                            vim.keymap.set("n", "<", ":tabprevious<CR>", { desc = "Go to the previous tab" })
                            vim.keymap.set("n", ">", ":tabnext<CR>", { desc = "Go to the next tab" })
                            vim.keymap.set("n", "tl", ":tablast<CR>", { desc = "Go to the last tab" })
                            vim.keymap.set("n", "tn", ":tabnew<CR>", { desc = "Create new tab" })
                            vim.keymap.set("n", "to", ":tabonly<CR>", { desc = "Close other tabs" })
                            vim.keymap.set("n", "tq", ":tabclose<CR>", { desc = "Close this tab" })
                            
                            vim.keymap.set("n", "<leader>1", ":tabn 1<CR>", { desc = "Go to tab 1" })
                            vim.keymap.set("n", "<leader>2", ":tabn 2<CR>", { desc = "Go to tab 2" })
                            vim.keymap.set("n", "<leader>3", ":tabn 3<CR>", { desc = "Go to tab 3" })
                            vim.keymap.set("n", "<leader>4", ":tabn 4<CR>", { desc = "Go to tab 4" })
                            vim.keymap.set("n", "<leader>5", ":tabn 5<CR>", { desc = "Go to tab 5" })
                            vim.keymap.set("n", "<leader>6", ":tabn 6<CR>", { desc = "Go to tab 6" })
                            vim.keymap.set("n", "<leader>7", ":tabn 7<CR>", { desc = "Go to tab 7" })
                            vim.keymap.set("n", "<leader>8", ":tabn 8<CR>", { desc = "Go to tab 8" })
                            vim.keymap.set("n", "<leader>9", ":tabn 9<CR>", { desc = "Go to tab 9" })
                            
                            vim.keymap.set("v", "<Tab>", ">gv", { desc = "Add indent" })
                            vim.keymap.set("v", "<S-Tab>", "<gv", { desc = "Remove indent " })
                            vim.keymap.set("v", "p", '"_dP', { desc = "Paste" })
                            
                            vim.keymap.set("t", "<esc>", [[<C-\><C-n>]])
                            vim.keymap.set("t", "<C-c>", [[<C-\><C-n>]])
                            
                            -- @see: https://github.com/mhinz/vim-galore#saner-behavior-of-n-and-n
                            vim.keymap.set("n", "n", "'Nn'[v:searchforward]", { expr = true, desc = "Next search result" })
                            vim.keymap.set("x", "n", "'Nn'[v:searchforward]", { expr = true, desc = "Next search result" })
                            vim.keymap.set("o", "n", "'Nn'[v:searchforward]", { expr = true, desc = "Next search result" })
                            vim.keymap.set("n", "N", "'nN'[v:searchforward]", { expr = true, desc = "Prev search result" })
                            vim.keymap.set("x", "N", "'nN'[v:searchforward]", { expr = true, desc = "Prev search result" })
                            vim.keymap.set("o", "N", "'nN'[v:searchforward]", { expr = true, desc = "Prev search result" })
                            
                            vim.keymap.set("n", "[d", function()
                              vim.diagnostic.jump({ count = -1, float = true })
                            end, { desc = "Go to prev diagnostic message" })
                            
                            vim.keymap.set("n", "]d", function()
                              vim.diagnostic.jump({ count = 1, float = true })
                            end, { desc = "Go to next diagnostic message" })
                            
                            vim.keymap.set("n", "[e", function()
                              vim.diagnostic.jump({ count = -1, float = true, severity = "ERROR" })
                            end, { desc = "Go to prev error message" })
                            
                            vim.keymap.set("n", "]e", function()
                              vim.diagnostic.jump({ count = 1, float = true, severity = "ERROR" })
                            end, { desc = "Go to next error message" })
                            
                            vim.keymap.set("n", "ge", vim.diagnostic.open_float, { desc = "Open diagnostic message" })
                            
                            vim.keymap.set("n", "]c", ":cnext<CR>", { desc = "Go to next quickfix item" })
                            
                            vim.keymap.set("n", "[c", ":cprev<CR>", { desc = "Go to prev quickfix item" })
                            
                            ---
                            --- Section: Plugins
                            ---
                            require("lazy").setup({
                              root = lazyroot .. "plugins",
                              spec = {
                                {
                                  "nvim-tree/nvim-web-devicons",
                                  lazy = true,
                                },
                                {
                                  "nvim-lua/plenary.nvim",
                                  lazy = true,
                                },
                                {
                                  "folke/snacks.nvim",
                                  lazy = false,
                                  priority = 1000,
                                  config = require("config.plugins.snacks").setup,
                                },
                                {
                                  "folke/trouble.nvim",
                                  cmd = { "ToggleTrouble", "Trouble" },
                                  config = require("config.plugins.trouble").setup,
                                },
                                {
                                  "folke/ts-comments.nvim",
                                  event = "VeryLazy",
                                  opts = {},
                                },
                                {
                                  "folke/lazydev.nvim",
                                  ft = "lua",
                                  opts = {
                                    library = {
                                      { path = "${3rd}/luv/library", words = { "vim%.uv" } },
                                      { path = "snacks.nvim",        words = { "Snacks" } },
                                    },
                                  },
                                },
                                {
                                  "tadaa/vimade",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.vimade").setup,
                                },
                                {
                                  "rmagatti/auto-session",
                                  cmd = { "SessionRestore" },
                                  config = require("config.plugins.auto-session").setup,
                                },
                                {
                                  "catppuccin/nvim",
                                  name = "catppuccin",
                                  config = require("config.plugins.catppuccin").setup,
                                },
                                {
                                  "stevearc/quicker.nvim",
                                  event = "FileType qf",
                                  config = require("config.plugins.quicker").setup,
                                },
                                {
                                  "eero-lehtinen/oklch-color-picker.nvim",
                                  version = "*",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.color-picker").setup,
                                },
                                {
                                  "kevinhwang91/nvim-hlslens",
                                  keys = { "n", "N", "*", "#", "/", "?" },
                                  config = require("config.plugins.hllens").setup,
                                },
                                {
                                  "petertriho/nvim-scrollbar",
                                  event = "User SuperLazy",
                                  dependencies = { "kevinhwang91/nvim-hlslens" },
                                  config = require("config.plugins.scrollbar").setup,
                                },
                                {
                                  "stevearc/conform.nvim",
                                  cmd = { "Format", "FormatWithBiome", "FormatWithLsp", "FormatWithPrettier" },
                                  keys = { { "<leader>m", "<CMD>Format<CR>", desc = "Format" } },
                                  config = require("config.plugins.conform").setup,
                                },
                                {
                                  "axelvc/template-string.nvim",
                                  ft = { "javascript", "typescript", "javascriptreact", "typescriptreact" },
                                  opts = {},
                                },
                                {
                                  "gbprod/substitute.nvim",
                                  keys = { { "X", "<CMD>lua require('substitute.exchange').visual()<CR>", mode = "x" } },
                                  opts = {},
                                },
                                {
                                  "kylechui/nvim-surround",
                                  keys = { { "S", mode = "v" }, { "cs" }, { "ds" }, { "ys" } },
                                  opts = {},
                                },
                                {
                                  "max397574/better-escape.nvim",
                                  event = "InsertEnter",
                                  config = require("config.plugins.better-escape").setup,
                                },
                                -- {
                                --   "windwp/nvim-autopairs",
                                --   enabled = false,
                                --   event = "InsertEnter",
                                --   config = require("config.plugins.autopairs").setup,
                                -- },
                                -- {
                                --   "windwp/nvim-ts-autotag",
                                --   enabled = false,
                                --   event = "InsertEnter",
                                --   config = require("config.plugins.autotag").setup,
                                -- },
                                {
                                  "shortcuts/no-neck-pain.nvim",
                                  cmd = "ToggleZenMode",
                                  keys = { { "<leader>z", "<CMD>ToggleZenMode<CR>" }, desc = "Toggle Zen Mode" },
                                  version = "*",
                                  config = require("config.plugins.no-neck-pain").setup,
                                },
                                {
                                  "nvim-tree/nvim-tree.lua",
                                  event = "User SuperLazy",
                                  cmd = { "NvimTreeFindFile", "NvimTreeOpen" },
                                  config = require("config.plugins.nvim-tree").setup,
                                },
                                {
                                  "stevearc/oil.nvim",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.oil").setup,
                                },
                                {
                                  "mvllow/modes.nvim",
                                  tag = "v0.2.1",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.modes").setup,
                                },
                                {
                                  "williamboman/mason.nvim",
                                  cmd = {
                                    "Mason",
                                    "MasonLog",
                                    "MasonUpdate",
                                    "MasonInstall",
                                    "MasonUninstall",
                                    "MasonUninstallAll",
                                  },
                                  config = require("config.plugins.mason").setup,
                                },
                                {
                                  "neovim/nvim-lspconfig",
                                  lazy = false,
                                  dependencies = { "b0o/schemastore.nvim" },
                                  config = require("config.plugins.lsp").setup,
                                },
                                {
                                  "saghen/blink.cmp",
                                  version = "1.*",
                                  event = { "User SuperLazy" },
                                  opts_extend = { "sources.default" },
                                  dependencies = { "L3MON4D3/LuaSnip", version = "v2.*" },
                                  config = require("config.plugins.blink").setup,
                                },
                                {
                                  "saghen/blink.pairs",
                                  enabled = false,
                                  event = "User SuperLazy",
                                  version = "*",
                                  dependencies = "saghen/blink.download",
                                  config = require("config.plugins.pairs").setup,
                                },
                                {
                                  "MagicDuck/grug-far.nvim",
                                  cmd = { "SearchFile", "SearchProject" },
                                  keys = {
                                    { "<leader>f", mode = "v",           ":SearchFileVisual<CR>",    desc = "Find in file (visual)" },
                                    { "<leader>s", mode = "v",           ":SearchProjectVisual<CR>", desc = "Find in project (visual)" },
                                    { "<C-F>",     ":SearchFile<CR>",    desc = "Find in file" },
                                    { "<C-S>",     ":SearchProject<CR>", desc = "Find in project" },
                                  },
                                  config = require("config.plugins.grug-far").setup,
                                },
                                {
                                  url = "https://codeberg.org/andyg/leap.nvim",
                                  keys = {
                                    {
                                      "<leader>;",
                                      function()
                                        require("leap").leap({ target_windows = require("leap.user").get_focusable_windows() })
                                      end,
                                    },
                                    {
                                      "s",
                                      function()
                                        require("leap").leap({ target_windows = require("leap.user").get_focusable_windows() })
                                      end,
                                    },
                                    {
                                      "gs",
                                      function()
                                        require("leap.remote").action()
                                      end,
                                    },
                                  },
                                  config = require("config.plugins.leap").setup,
                                },
                                {
                                  "Wansmer/treesj",
                                  keys = {
                                    { "<leader>tj", ":TSJJoin<CR>",   silent = true, desc = "Join TS nodes" },
                                    { "<leader>tm", ":TSJToggle<CR>", silent = true, desc = "Toggle TS nodes" },
                                    { "<leader>ts", ":TSJSplit<CR>",  silent = true, desc = "Split TS nodes" },
                                  },
                                  opts = {},
                                },
                                {
                                  "NeogitOrg/neogit",
                                  event = "User SuperLazy",
                                  dependencies = { "sindrets/diffview.nvim" },
                                  config = require("config.plugins.neogit").setup,
                                },
                                {
                                  "lewis6991/gitsigns.nvim",
                                  enabled = false,
                                  event = "User SuperLazy",
                                  config = require("config.plugins.gitsigns").setup,
                                },
                                {
                                  "mrjones2014/smart-splits.nvim",
                                  keys = {
                                    -- stylua: ignore start
                                    { "<C-h>", function() require('smart-splits').move_cursor_left() end,  desc = "Move cursor left" },
                                    { "<C-j>", function() require('smart-splits').move_cursor_down() end,  desc = "Move cursor down" },
                                    { "<C-k>", function() require('smart-splits').move_cursor_up() end,    desc = "Move cursor up" },
                                    { "<C-l>", function() require('smart-splits').move_cursor_right() end, desc = "Move cursor right" },
                                    -- stylua: ignore end
                                  },
                                  config = require("config.plugins.smart-splits").setup,
                                },
                                {
                                  "jake-stewart/multicursor.nvim",
                                  event = "VeryLazy",
                                  branch = "1.0",
                                  config = require("config.plugins.multicursor").setup,
                                },
                                {
                                  "wurli/visimatch.nvim",
                                  keys = { "V", "v" },
                                  opts = { hl_group = "WVisiMatch", chars_lower_limit = 2 },
                                },
                                {
                                  "RRethy/vim-illuminate",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.illuminate").setup,
                                },
                                {
                                  "nvim-treesitter/nvim-treesitter-context",
                                  cmd = "ToggleTreesitterContext",
                                  config = require("config.plugins.treesitter-context").setup,
                                },
                                {
                                  "nvim-treesitter/nvim-treesitter-textobjects",
                                  branch = "main",
                                  keys = {
                                    {
                                      "af",
                                      function()
                                        require("nvim-treesitter-textobjects.select").select_textobject("@function.outer", "textobjects")
                                      end,
                                      mode = { "x", "o" },
                                      desc = "Select around function",
                                    },
                                    {
                                      "if",
                                      function()
                                        require("nvim-treesitter-textobjects.select").select_textobject("@function.inner", "textobjects")
                                      end,
                                      mode = { "x", "o" },
                                      desc = "Select inside function",
                                    },
                                  },
                                  opts = {},
                                },
                                {
                                  -- NOTE: you may need to rm -rf ~/.local/share/nvim/site/queries/
                                  -- NOTE: you need to install tree-sitter-cli
                                  "nvim-treesitter/nvim-treesitter",
                                  event = { "BufReadPost", "BufNewFile" },
                                  branch = "main",
                                  build = ":TSUpdate",
                                  config = require("config.plugins.treesitter").setup,
                                },
                                {
                                  -- NOTE: if you want to see the little fold icons in the gutter you have to load this
                                  -- event = "User SuperLazy",
                                  "kevinhwang91/nvim-ufo",
                                  -- stylua: ignore start
                                  keys = {
                                    "zc", "zC", "zo", "zO", "za", "zA",
                                    "zm", "zM", "zr", "zR",
                                    "zj", "zk", "zv", "zx",
                                    "zp", "]f", "[f",
                                  },
                                  -- stylua: ignore end
                                  dependencies = { "kevinhwang91/promise-async" },
                                  config = require("config.plugins.ufo").setup,
                                },
                                {
                                  "monaqa/dial.nvim",
                                  event = "User SuperLazy",
                                  config = require("config.plugins.dial").setup,
                                },
                              },
                              performance = {
                                cache = {
                                  enabled = true,
                                },
                                rtp = {
                                  disabled_plugins = {
                                    "editorconfig",
                                    "getscriptPlugin",
                                    "gzip",
                                    "matchit",
                                    -- "matchparen",
                                    "netrwPlugin",
                                    "osc52",
                                    "remotePlugin",
                                    "rplugin",
                                    "spellfile",
                                    "tarPlugin",
                                    "tohtml",
                                    "tutor",
                                    "vimballPlugin",
                                    "zipPlugin",
                                  },
                                },
                              },
                              ui = {
                                backdrop = 100,
                                border = "rounded",
                              },
                            })
                            
                            require("config.lastplace")
                            require("config.tabbar")
                            require("config.winbar")
                            
                            ---
                            --- Section: Autocmds
                            ---
                            vim.api.nvim_create_autocmd({ "FocusGained", "BufEnter" }, {
                              group = vim.api.nvim_create_augroup("reload-file-static", { clear = true }),
                              desc = "Reload buffer on focus",
                              callback = function()
                                if vim.fn.getcmdwintype() == "" then
                                  vim.cmd("checktime")
                                end
                              end,
                            })
                            
                            -- show
                            -- local was_list_enabled = _G.show_invisible_chars
                            -- vim.api.nvim_create_autocmd("ModeChanged", {
                            --   pattern = "*:[vV]", -- Entering Visual mode (includes Visual Line and Block)
                            --   callback = function()
                            --     was_list_enabled = vim.wo.list
                            --     vim.wo.list = true
                            --   end,
                            -- })
                            --
                            -- vim.api.nvim_create_autocmd("ModeChanged", {
                            --   pattern = "[vV]:*", -- Leaving Visual mode
                            --   callback = function()
                            --     vim.wo.list = was_list_enabled
                            --   end,
                            -- })
                            
                            -- vim.api.nvim_create_autocmd({ "CursorHold" }, {
                            --   group = vim.api.nvim_create_augroup("reload-file-dyanmic", { clear = true }),
                            --   desc = "Reload buffer on focus",
                            --   callback = debounce(function()
                            --     if vim.fn.getcmdwintype() == "" then
                            --       vim.cmd("checktime")
                            --     end
                            --   end, 1000),
                            -- })
                            
                            -- restore cursor to file position in previous editing session
                            vim.api.nvim_create_autocmd("BufReadPost", {
                              callback = function(args)
                                local mark = vim.api.nvim_buf_get_mark(args.buf, '"')
                                local line_count = vim.api.nvim_buf_line_count(args.buf)
                                if mark[1] > 0 and mark[1] <= line_count then
                                  vim.api.nvim_buf_call(args.buf, function()
                                    vim.cmd('normal! g`"zz')
                                  end)
                                end
                              end,
                            })
                            
                            vim.api.nvim_create_autocmd("VimResized", {
                              group = vim.api.nvim_create_augroup("vim-resized", { clear = true }),
                              desc = "Resset buffer size on window resize",
                              callback = function()
                                local current_tab = vim.fn.tabpagenr()
                                vim.cmd("tabdo wincmd =")
                                vim.cmd("tabnext " .. current_tab)
                              end,
                            })
                            
                            vim.api.nvim_create_autocmd("TextYankPost", {
                              group = vim.api.nvim_create_augroup("highlight-yank", { clear = true }),
                              desc = "Highlight yanked lines",
                              callback = function()
                                vim.highlight.on_yank()
                              end,
                            })
                            
                            vim.api.nvim_create_autocmd("VimEnter", {
                              group = vim.api.nvim_create_augroup("user-lazy-done", { clear = true }),
                              desc = "Custom lazy load autocmd",
                              callback = function()
                                vim.defer_fn(function()
                                  vim.api.nvim_exec_autocmds("User", { pattern = "SuperLazy" })
                                end, 200)
                              end,
                            })
                            
                            ---
                            --- Section: Commands
                            ---
                            --- @param value string
                            local function print_and_copy(value)
                              vim.cmd("call setreg('+', '" .. vim.fn.escape(value, "'") .. "')")
                              print('Copied: "' .. value .. '"')
                            end
                            
                            vim.api.nvim_create_user_command("BufOnly", function()
                              vim.cmd("%bdelete|edit #|normal`")
                            end, {})
                            
                            vim.api.nvim_create_user_command("CopyFiletype", function()
                              print_and_copy(vim.bo.filetype)
                            end, {})
                            
                            vim.api.nvim_create_user_command("CopyAbsolutePath", function()
                              print_and_copy(vim.fn.expand("%:~p"))
                            end, {})
                            
                            vim.api.nvim_create_user_command("CopyRelativePath", function()
                              print_and_copy(vim.fn.fnamemodify(vim.fn.expand("%"), ":~:."))
                            end, {})
                            
                            vim.api.nvim_create_user_command("CopyHighlightGroup", function()
                              local line = vim.fn.line(".")
                              local col = vim.fn.col(".")
                            
                              local captures = vim.treesitter.get_captures_at_pos(0, line - 1, col - 1)
                              if #captures > 0 then
                                vim.notify("treesitter::")
                                print_and_copy(captures[#captures].capture)
                                return
                              end
                            
                              local synID = vim.fn.synID(line, col, 1)
                              local synName = vim.fn.synIDattr(synID, "name")
                              vim.notify("OG colors::")
                              print_and_copy(synName)
                            end, {})
                            
                            vim.api.nvim_create_user_command("Datetime", function()
                              local datetime = os.date("%A, %B, %d, %Y %I:%M%p")
                              vim.api.nvim_put({ datetime }, "c", true, true)
                            end, {})
                            
                            vim.api.nvim_create_user_command("ToggleDiagnostics", function()
                              _G.show_diagnostics = not _G.show_diagnostics
                              vim.diagnostic.enable(_G.show_diagnostics)
                            end, {})
                            
                            vim.api.nvim_create_user_command("ToggleDiagnosticText", function()
                              local config = vim.diagnostic.config()
                              if config ~= nil then
                                if not config.virtual_text then
                                  _G.show_diagnostics = true
                                  vim.diagnostic.enable(true)
                                  _G.show_diagnostics_text = true
                                else
                                  _G.show_diagnostics_text = false
                                end
                                vim.diagnostic.config({ virtual_text = _G.show_diagnostics_text })
                              end
                            end, {})
                            
                            vim.api.nvim_create_user_command("ToggleDiagnosticUnderline", function()
                              local config = vim.diagnostic.config()
                              if config ~= nil then
                                if not config.underline then
                                  _G.show_diagnostics = true
                                  vim.diagnostic.enable(true)
                                  _G.show_diagnostics_underline = true
                                else
                                  _G.show_diagnostics_underline = false
                                end
                                vim.diagnostic.config({ underline = _G.show_diagnostics_underline })
                              end
                            end, {})
                            
                            --- @type table<string, boolean>
                            local excluded_filetypes = {
                              ["NeogitStatus"] = true,
                              ["NvimTree"] = true,
                              ["grug-far"] = true,
                              ["no-neck-pain"] = true,
                              ["snacks_dashboard"] = true,
                              ["spectre_panel"] = true,
                              ["toggleterm"] = true,
                            }
                            
                            vim.api.nvim_create_user_command("ToggleLineWrap", function()
                              _G.enable_line_wrap = not _G.enable_line_wrap
                            
                              for _, win_id in ipairs(vim.api.nvim_list_wins()) do
                                local buf_id = vim.api.nvim_win_get_buf(win_id)
                                local buf_filetype = vim.bo[buf_id].filetype
                            
                                if not excluded_filetypes[buf_filetype] then
                                  vim.api.nvim_set_option_value("wrap", _G.enable_line_wrap, { win = win_id })
                                  vim.api.nvim_set_option_value("linebreak", _G.enable_line_wrap, { win = win_id })
                                end
                              end
                            end, {})
                            
                            vim.api.nvim_create_user_command("DisableLineWrap", function()
                              _G.enable_line_wrap = false
                            
                              for _, win_id in ipairs(vim.api.nvim_list_wins()) do
                                local buf_id = vim.api.nvim_win_get_buf(win_id)
                                local buf_filetype = vim.bo[buf_id].filetype
                            
                                if not excluded_filetypes[buf_filetype] then
                                  vim.api.nvim_set_option_value("wrap", _G.enable_line_wrap, { win = win_id })
                                  vim.api.nvim_set_option_value("linebreak", _G.enable_line_wrap, { win = win_id })
                                end
                              end
                            end, {})
                            
                            vim.api.nvim_create_user_command("ToggleInvisibleChars", function()
                              _G.show_invisible_chars = not _G.show_invisible_chars
                              vim.opt.list = _G.show_invisible_chars
                            end, {})
                            
                            vim.api.nvim_create_user_command("ToggleInlayHints", function()
                              _G.show_inlay_hints = not _G.show_inlay_hints
                              vim.lsp.inlay_hint.enable(_G.show_inlay_hints)
                            end, {})
                            
                            ---
                            --- personal plugin START
                            ---
                            --- @type table<string, boolean>
                            local is_affected_by_line_numbers = {
                              ["NeogitStatus"] = true,
                              ["NvimTree"] = true,
                              ["grug-far"] = true,
                              ["help"] = true,
                              ["neo-tree"] = true,
                              ["no-neck-pain"] = true,
                              ["oil"] = false,
                              ["qf"] = true,
                              ["snacks_dashboard"] = true,
                              ["spectre_panel"] = true,
                              ["toggleterm"] = true,
                            }
                            
                            local function set_line_numbers(nu, rnu)
                              -- update each window
                              for _, win_id in ipairs(vim.api.nvim_list_wins()) do
                                local buf_id = vim.api.nvim_win_get_buf(win_id)
                                local filetype = vim.bo[buf_id].filetype
                                if not is_affected_by_line_numbers[filetype] then
                                  vim.api.nvim_set_option_value("number", nu, { win = win_id })
                                  vim.api.nvim_set_option_value("relativenumber", rnu, { win = win_id })
                                end
                              end
                            end
                            
                            -- TODO: implement a toggle with a previous values cache.
                            -- if there are previous values use them, otherwise don't.
                            vim.api.nvim_create_user_command("HideLineNumbers", function()
                              set_line_numbers(false, false)
                              vim.cmd("e!")
                            end, {})
                            
                            vim.api.nvim_create_user_command("ShowLineNumbers", function()
                              set_line_numbers(true, false)
                              vim.cmd("e!")
                            end, {})
                            
                            vim.api.nvim_create_user_command("ShowRelativeLineNumbers", function()
                              set_line_numbers(true, true)
                              vim.cmd("e!")
                            end, {})
                            ---
                            --- personal plugin END
                            ---
                            
                            vim.api.nvim_create_user_command("ToggleCursorLine", function()
                              _G.show_cursorline = not _G.show_cursorline
                              vim.opt.cursorline = _G.show_cursorline
                            end, {})
                            
                            ---
                            --- Section: Diagnostics
                            ---
                            vim.diagnostic.config({
                              float = { border = "rounded" },
                              -- signs = false,
                              signs = {
                                -- NOTE: if you want signs
                                text = {
                                  [vim.diagnostic.severity.ERROR] = "", --signs.icons.square,
                                  [vim.diagnostic.severity.HINT] = "", --signs.icons.square,
                                  [vim.diagnostic.severity.INFO] = "", --signs.icons.square,
                                  [vim.diagnostic.severity.WARN] = "", --signs.icons.square,
                                },
                                -- NOTE: if you want to highlight the number line
                                -- numhl = {
                                --   [vim.diagnostic.severity.ERROR] = "DiagnosticSignError",
                                --   [vim.diagnostic.severity.HINT] = "DiagnosticSignHint",
                                --   [vim.diagnostic.severity.INFO] = "DiagnosticSignInfo",
                                --   [vim.diagnostic.severity.WARN] = "DiagnosticSignWarn",
                                -- },
                              },
                              underline = _G.show_diagnostics_underline,
                              virtual_text = _G.show_diagnostics_text,
                              virtual_lines = false,
                            })
                            vim.diagnostic.enable(_G.show_diagnostics)
                            
                            ---
                            --- Section: Filetypes
                            ---
                            vim.filetype.add({
                              extension = {
                                env = "sh",
                                gleam = "gleam",
                                mdc = "mdc",
                                mdx = "mdx",
                                templ = "templ",
                              },
                              filename = {
                                [".envrc"] = "sh",
                                ["Brewfile"] = "sh",
                                ["go.mod"] = "gomod",
                                ["go.sum"] = "gosum",
                              },
                              pattern = {
                                [".env%..*"] = "sh",
                              },
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/filetype.lua
Sourced 2 times
Total time:   0.005380
 Self time:   0.004648

count  total (s)   self (s)
    1              0.000013 if vim.g.did_load_filetypes then
    1              0.000710   return
    1              0.000003 end
                            vim.g.did_load_filetypes = 1
                            
                            vim.api.nvim_create_augroup('filetypedetect', { clear = false })
                            
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile', 'StdinReadPost' }, {
                              group = 'filetypedetect',
                              callback = function(args)
                                if not vim.api.nvim_buf_is_valid(args.buf) then
                                  return
                                end
                                local ft, on_detect, is_fallback = vim.filetype.match({
                                  -- The unexpanded file name is needed here. #27914
                                  -- However, bufname() can't be used, as it doesn't work with :doautocmd. #31306
                                  filename = args.file,
                                  buf = args.buf,
                                })
                                if ft then
                                  -- on_detect is called before setting the filetype so that it can set any buffer local
                                  -- variables that may be used the filetype's ftplugin
                                  if on_detect then
                                    on_detect(args.buf)
                                  end
                            
                                  vim._with({ buf = args.buf }, function()
                                    vim.api.nvim_cmd({
                                      cmd = 'setf',
                                      args = (is_fallback and { 'FALLBACK', ft } or { ft }),
                                    }, {})
                                  end)
                                end
                              end,
                            })
                            
                            -- Set up the autocmd for user scripts.vim
                            vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, {
                              group = 'filetypedetect',
                              command = "if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif",
                            })
                            
                            vim.api.nvim_create_autocmd('StdinReadPost', {
                              group = 'filetypedetect',
                              command = 'if !did_filetype() | runtime! scripts.vim | endif',
                            })
                            
                            if not vim.g.ft_ignore_pat then
                              vim.g.ft_ignore_pat = '\\.\\(Z\\|gz\\|bz2\\|zip\\|tgz\\)$'
                            end
                            
                            -- These *must* be sourced after the autocommands above are created
                            vim.cmd([[
                              augroup filetypedetect
                              runtime! ftdetect/*.{vim,lua}
                              augroup END
                            ]])

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/snacks.nvim/plugin/snacks.lua
Sourced 1 time
Total time:   0.006479
 Self time:   0.006479

count  total (s)   self (s)
                            require("snacks")

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-lspconfig/plugin/lspconfig.lua
Sourced 1 time
Total time:   0.003912
 Self time:   0.003912

count  total (s)   self (s)
                            if vim.g.lspconfig ~= nil then
                              return
                            end
                            vim.g.lspconfig = 1
                            
                            if vim.fn.exists(':lsp') == 2 then
                              return
                            end
                            
                            if vim.fn.has('nvim-0.11') == 0 then
                              vim.deprecate('nvim-lspconfig support for Nvim 0.10 or older', 'Nvim 0.11+', 'v3.0.0', 'nvim-lspconfig', false)
                            end
                            
                            local api, lsp = vim.api, vim.lsp
                            local util = require('lspconfig.util')
                            
                            local completion_sort = function(items)
                              table.sort(items)
                              return items
                            end
                            
                            local lsp_complete_configured_servers = function(arg)
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, util.available_servers()))
                            end
                            
                            local lsp_get_active_clients = function(arg)
                              local clients = vim.tbl_map(function(client)
                                return ('%s'):format(client.name)
                              end, util.get_managed_clients())
                            
                              return completion_sort(vim.tbl_filter(function(s)
                                return s:sub(1, #arg) == arg
                              end, clients))
                            end
                            
                            ---@return vim.lsp.Client[] clients
                            local get_clients_from_cmd_args = function(arg)
                              local result = {}
                              local managed_clients = util.get_managed_clients()
                              local clients = {}
                              for _, client in pairs(managed_clients) do
                                clients[client.name] = client
                              end
                            
                              local err_msg = ''
                              arg = arg:gsub('[%a-_]+', function(name)
                                if clients[name] then
                                  return clients[name].id
                                end
                                err_msg = err_msg .. ('config "%s" not found\n'):format(name)
                                return ''
                              end)
                              for id in (arg or ''):gmatch '(%d+)' do
                                local client = lsp.get_client_by_id(assert(tonumber(id)))
                                if client == nil then
                                  err_msg = err_msg .. ('client id "%s" not found\n'):format(id)
                                end
                                result[#result + 1] = client
                              end
                            
                              if err_msg ~= '' then
                                vim.notify(('nvim-lspconfig:\n%s'):format(err_msg:sub(1, -2)), vim.log.levels.WARN)
                                return result
                              end
                            
                              if #result == 0 then
                                return managed_clients
                              end
                              return result
                            end
                            
                            -- Called from plugin/lspconfig.vim because it requires knowing that the last
                            -- script in scriptnames to be executed is lspconfig.
                            api.nvim_create_user_command('LspInfo', ':checkhealth vim.lsp', { desc = 'Alias to `:checkhealth vim.lsp`' })
                            
                            api.nvim_create_user_command('LspLog', function()
                              vim.cmd(string.format('tabnew %s', lsp.log.get_filename()))
                            end, {
                              desc = 'Opens the Nvim LSP client log.',
                            })
                            
                            if vim.fn.has('nvim-0.11.2') == 1 then
                              local complete_client = function(arg)
                                return vim
                                  .iter(vim.lsp.get_clients())
                                  :map(function(client)
                                    return client.name
                                  end)
                                  :filter(function(name)
                                    return name:sub(1, #arg) == arg
                                  end)
                                  :totable()
                              end
                            
                              local complete_config = function(arg)
                                return vim
                                  .iter(vim.api.nvim_get_runtime_file(('lsp/%s*.lua'):format(arg), true))
                                  :map(function(path)
                                    local file_name = path:match('[^/]*.lua$')
                                    return file_name:sub(0, #file_name - 4)
                                  end)
                                  :totable()
                              end
                            
                              api.nvim_create_user_command('LspStart', function(info)
                                local servers = info.fargs
                            
                                -- Default to enabling all servers matching the filetype of the current buffer.
                                -- This assumes that they've been explicitly configured through `vim.lsp.config`,
                                -- otherwise they won't be present in the private `vim.lsp.config._configs` table.
                                if #servers == 0 then
                                  local filetype = vim.bo.filetype
                                  for name, _ in pairs(vim.lsp.config._configs) do
                                    local filetypes = vim.lsp.config[name].filetypes
                                    if filetypes and vim.tbl_contains(filetypes, filetype) then
                                      table.insert(servers, name)
                                    end
                                  end
                                end
                            
                                vim.lsp.enable(servers)
                              end, {
                                desc = 'Enable and launch a language server',
                                nargs = '?',
                                complete = complete_config,
                              })
                            
                              api.nvim_create_user_command('LspRestart', function(info)
                                local client_names = info.fargs
                            
                                -- Default to restarting all active servers
                                if #client_names == 0 then
                                  client_names = vim
                                    .iter(vim.lsp.get_clients())
                                    :map(function(client)
                                      return client.name
                                    end)
                                    :totable()
                                end
                            
                                for name in vim.iter(client_names) do
                                  if vim.lsp.config[name] == nil then
                                    vim.notify(("Invalid server name '%s'"):format(name))
                                  else
                                    vim.lsp.enable(name, false)
                                    if info.bang then
                                      vim.iter(vim.lsp.get_clients({ name = name })):each(function(client)
                                        client:stop(true)
                                      end)
                                    end
                                  end
                                end
                            
                                local timer = assert(vim.uv.new_timer())
                                timer:start(500, 0, function()
                                  for name in vim.iter(client_names) do
                                    vim.schedule_wrap(vim.lsp.enable)(name)
                                  end
                                end)
                              end, {
                                desc = 'Restart the given client',
                                nargs = '?',
                                bang = true,
                                complete = complete_client,
                              })
                            
                              api.nvim_create_user_command('LspStop', function(info)
                                local client_names = info.fargs
                            
                                -- Default to disabling all servers on current buffer
                                if #client_names == 0 then
                                  client_names = vim
                                    .iter(vim.lsp.get_clients())
                                    :map(function(client)
                                      return client.name
                                    end)
                                    :totable()
                                end
                            
                                for name in vim.iter(client_names) do
                                  if vim.lsp.config[name] == nil then
                                    vim.notify(("Invalid server name '%s'"):format(name))
                                  else
                                    vim.lsp.enable(name, false)
                                    if info.bang then
                                      vim.iter(vim.lsp.get_clients({ name = name })):each(function(client)
                                        client:stop(true)
                                      end)
                                    end
                                  end
                                end
                              end, {
                                desc = 'Disable and stop the given client',
                                nargs = '?',
                                bang = true,
                                complete = complete_client,
                              })
                            
                              return
                            end
                            
                            api.nvim_create_user_command('LspStart', function(info)
                              local server_name = string.len(info.args) > 0 and info.args or nil
                              if server_name then
                                local config = require('lspconfig.configs')[server_name]
                                if config then
                                  config.launch()
                                  return
                                end
                              end
                            
                              local matching_configs = util.get_config_by_ft(vim.bo.filetype)
                              for _, config in ipairs(matching_configs) do
                                config.launch()
                              end
                            end, {
                              desc = 'Manually launches a language server',
                              nargs = '?',
                              complete = lsp_complete_configured_servers,
                            })
                            
                            api.nvim_create_user_command('LspRestart', function(info)
                              local detach_clients = {}
                              for _, client in ipairs(get_clients_from_cmd_args(info.args)) do
                                -- Can remove diagnostic disabling when changing to client:stop() in nvim 0.11+
                                --- @diagnostic disable: missing-parameter
                                client.stop()
                                if vim.tbl_count(client.attached_buffers) > 0 then
                                  detach_clients[client.name] = { client, lsp.get_buffers_by_client_id(client.id) }
                                end
                              end
                              local timer = assert(vim.uv.new_timer())
                              timer:start(
                                500,
                                100,
                                vim.schedule_wrap(function()
                                  for client_name, tuple in pairs(detach_clients) do
                                    if require('lspconfig.configs')[client_name] then
                                      local client, attached_buffers = unpack(tuple)
                                      if client.is_stopped() then
                                        for _, buf in pairs(attached_buffers) do
                                          require('lspconfig.configs')[client_name].launch(buf)
                                        end
                                        detach_clients[client_name] = nil
                                      end
                                    end
                                  end
                            
                                  if next(detach_clients) == nil and not timer:is_closing() then
                                    timer:close()
                                  end
                                end)
                              )
                            end, {
                              desc = 'Manually restart the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_clients,
                            })
                            
                            api.nvim_create_user_command('LspStop', function(info)
                              ---@type string
                              local args = info.args
                              local force = false
                              args = args:gsub('%+%+force', function()
                                force = true
                                return ''
                              end)
                            
                              local clients = {}
                            
                              -- default to stopping all servers on current buffer
                              if #args == 0 then
                                clients = vim.lsp.get_clients({ bufnr = vim.api.nvim_get_current_buf() })
                              else
                                clients = get_clients_from_cmd_args(args)
                              end
                            
                              for _, client in ipairs(clients) do
                                -- Can remove diagnostic disabling when changing to client:stop(force) in nvim 0.11+
                                --- @diagnostic disable: param-type-mismatch
                                client.stop(force)
                              end
                            end, {
                              desc = 'Manually stops the given language client(s)',
                              nargs = '?',
                              complete = lsp_get_active_clients,
                            })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/catppuccin/colors/catppuccin-latte.vim
Sourced 1 time
Total time:   0.006650
 Self time:   0.006650

count  total (s)   self (s)
    1              0.006602 lua require("catppuccin").load "latte"

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/man.lua
Sourced 1 time
Total time:   0.002902
 Self time:   0.002902

count  total (s)   self (s)
                            if vim.g.loaded_man ~= nil then
                              return
                            end
                            vim.g.loaded_man = true
                            
                            vim.api.nvim_create_user_command('Man', function(params)
                              local man = require('man')
                              if params.bang then
                                man.init_pager()
                              else
                                local _, err = pcall(man.open_page, params.count, params.smods, params.fargs)
                                if err then
                                  vim.notify('man.lua: ' .. err, vim.log.levels.ERROR)
                                end
                              end
                            end, {
                              bang = true,
                              bar = true,
                              range = true,
                              addr = 'other',
                              nargs = '*',
                              complete = function(...)
                                return require('man').man_complete(...)
                              end,
                            })
                            
                            local augroup = vim.api.nvim_create_augroup('nvim.man', {})
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = augroup,
                              pattern = 'man://*',
                              nested = true,
                              callback = function(params)
                                local err = require('man').read_page(assert(params.match:match('man://(.*)')))
                                if err then
                                  vim.notify('man.lua: ' .. err, vim.log.levels.ERROR)
                                end
                              end,
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2025 Apr 08
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - Vim has no support for :defer
    1              0.000027 if exists("g:loaded_matchparen") || &cp ||
                                  \ exists(":defer") != 2
                              finish
    1              0.000002 endif
    1              0.000006 let g:loaded_matchparen = 1
                            
    1              0.000003 if !exists("g:matchparen_timeout")
    1              0.000002   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000003 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
    1              0.000003 if !exists("g:matchparen_disable_cursor_hl")
    1              0.000003   let g:matchparen_disable_cursor_hl = 0
    1              0.000001 endif
                            
    1              0.000005 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000019   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
    1              0.000004   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
    1              0.000005   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
    1              0.000005   autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000003   autocmd! TextChangedP * call s:Remove_Matches()
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000008 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000001 endif
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000010 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000004 func s:Highlight_Matching_Pair()
                              if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
                              endif
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let c_before = text->strpart(0, c_col - 1)->slice(-1)
                              let c = text->strpart(c_col - 1)->slice(0, 1)
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '"
                                      \ .. 'string\|character\|singlequote\|escape\|symbol\|comment'
                                      \ .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 &&
                                    \ synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name")
                                    \ =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))'
                                    \ . '->indexof({_, id -> synIDattr(id, "name") =~? '
                                    \ . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
                                if !g:matchparen_disable_cursor_hl
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000003 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000008 command DoMatchParen call s:DoMatchParen()
    1              0.000004 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000002 func s:NoMatchParen()
                              let w = winnr()
                              noau windo call s:Remove_Matches()
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/nvim/net.lua
Sourced 1 time
Total time:   0.002669
 Self time:   0.002669

count  total (s)   self (s)
                            vim.g.loaded_remote_file_loader = true
                            
                            --- Callback for BufReadCmd on remote URLs.
                            --- @param args { buf: integer }
                            local function on_remote_read(args)
                              if vim.fn.executable('curl') ~= 1 then
                                vim.api.nvim_echo({
                                  { 'Warning: `curl` not found; remote URL loading disabled.', 'WarningMsg' },
                                }, true, {})
                                return true
                              end
                            
                              local bufnr = args.buf
                              local url = vim.api.nvim_buf_get_name(bufnr)
                              local view = vim.fn.winsaveview()
                            
                              vim.api.nvim_echo({ { 'Fetching ' .. url .. ' …', 'MoreMsg' } }, true, {})
                            
                              vim.net.request(
                                url,
                                { retry = 3 },
                                vim.schedule_wrap(function(err, content)
                                  if err then
                                    vim.notify('Failed to fetch ' .. url .. ': ' .. tostring(err), vim.log.levels.ERROR)
                                    vim.fn.winrestview(view)
                                    return
                                  end
                            
                                  local lines = vim.split(content.body, '\n', { plain = true })
                                  vim.api.nvim_buf_set_lines(bufnr, 0, -1, true, lines)
                                  vim.api.nvim_exec_autocmds('BufRead', { group = 'filetypedetect', buffer = bufnr })
                                  vim.bo[bufnr].modified = false
                            
                                  vim.fn.winrestview(view)
                                  vim.api.nvim_echo({ { 'Loaded ' .. url, 'Normal' } }, true, {})
                                end)
                              )
                            end
                            
                            vim.api.nvim_create_autocmd('BufReadCmd', {
                              group = vim.api.nvim_create_augroup('nvim.net.remotefile', {}),
                              pattern = { 'http://*', 'https://*' },
                              desc = 'Edit remote files (:edit https://example.com)',
                              callback = on_remote_read,
                            })

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/shada.lua
Sourced 1 time
Total time:   0.004526
 Self time:   0.004526

count  total (s)   self (s)
                            if vim.g.loaded_shada_plugin then
                              return
                            end
                            vim.g.loaded_shada_plugin = 1
                            
                            local augroup = vim.api.nvim_create_augroup('nvim.shada', {})
                            
                            ---@type fun(binstrings: string[]): string[]
                            local shada_get_strings = vim.fn['shada#get_strings']
                            
                            ---@type fun(strings: string[]): string[]
                            local shada_get_binstrings = vim.fn['shada#get_binstrings']
                            
                            ---Ensures that pattern and augroup are set correctly.
                            ---@param event string|string[]
                            ---@param opts vim.api.keyset.create_autocmd
                            ---@param fn fun(args: vim.api.keyset.create_autocmd.callback_args): boolean?
                            local function def_autocmd(event, opts, fn)
                              opts = opts or {}
                              opts.group = augroup
                              opts.pattern = { '*.shada', '*.shada.tmp.[a-z]' }
                              opts.callback = function(ev)
                                if vim.v.cmdarg ~= '' then
                                  error('++opt not supported')
                                end
                                fn(ev)
                              end
                              vim.api.nvim_create_autocmd(event, opts)
                            end
                            
                            ---Read shada strings from file.
                            ---@param file string Filename
                            ---@return string[] # lines from shada file
                            local function read_strings(file)
                              local f = assert(io.open(file, 'rb'))
                              local strings = f:read('*a')
                              f:close()
                              return shada_get_strings(strings)
                            end
                            
                            def_autocmd('BufReadCmd', {}, function(ev)
                              local lines = read_strings(ev.file)
                              vim.api.nvim_buf_set_lines(ev.buf, 0, -1, false, lines)
                              vim.bo[ev.buf].filetype = 'shada'
                            end)
                            
                            def_autocmd('FileReadCmd', {}, function(ev)
                              local lines = read_strings(ev.file)
                              local lnum = vim.fn.line("'[")
                              vim.api.nvim_buf_set_lines(ev.buf, lnum, lnum, true, lines)
                            end)
                            
                            def_autocmd('BufWriteCmd', {}, function(ev)
                              local buflines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
                              local ret = vim.fn.writefile(shada_get_binstrings(buflines), ev.file, 'b')
                              if ret == 0 then
                                vim.bo[ev.buf].modified = false
                              end
                            end)
                            
                            def_autocmd({ 'FileWriteCmd', 'FileAppendCmd' }, {}, function(ev)
                              vim.fn.writefile(
                                shada_get_binstrings(
                                  vim.fn.getline(
                                    math.min(vim.fn.line("'["), vim.fn.line("']")),
                                    math.max(vim.fn.line("'["), vim.fn.line("']"))
                                  ) --[=[@as string[]]=]
                                ),
                                ev.file,
                                ev.event == 'FileAppendCmd' and 'ab' or 'b'
                              )
                            end)
                            
                            def_autocmd('SourceCmd', {}, function(ev)
                              vim.cmd.rshada(vim.fn.fnameescape(ev.file))
                            end)

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.004805
 Self time:   0.004535

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000019 if !has("syntax")
                              finish
    1              0.000002 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000007 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
    1              0.000001 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1   0.004628   0.004444 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000003 if exists("did_load_filetypes")
    1              0.000002   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    1              0.000000 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected
                            " unless treesitter highlighting is enabled.
                            " Avoid an error when 'verbose' is set and <amatch> expansion fails.
    1              0.000003 augroup syntaxset
    1              0.000004   au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
    1              0.000001 augroup END
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1   0.000091   0.000005 doautoall syntaxset FileType
    1              0.000001 if !s:did_ft
                              doautoall filetypedetect BufRead
    1              0.000003 endif

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	The Vim Project <https://github.com/vim/vim>
                            " Last Change:	2023 Aug 10
                            " Former Maintainer:	Bram Moolenaar <Bram@vim.org>
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000016 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " let others know that syntax has been switched on
    1              0.000007 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000005 let s:cpo_save = &cpo
    1              0.000011 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000007 au! Syntax
                            
    1              0.000011 au Syntax *		call s:SynSet()
                            
    1              0.000006 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              0verbose let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    1              0.000028 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000002 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    1              0.000000 endif
                            
                            " Restore 'cpoptions'
    1              0.000003 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/vim-illuminate/plugin/illuminate.vim
Sourced 1 time
Total time:   0.038694
 Self time:   0.038694

count  total (s)   self (s)
                            " illuminate.vim - Vim plugin for selectively illuminating other uses of current word
                            " Maintainer:	Adam P. Regasz-Rethy (RRethy) <rethy.spud@gmail.com>
                            " Version: 2.0
                            
    1              0.000020 if exists('g:loaded_illuminate')
                              finish
    1              0.000001 endif
                            
    1              0.000007 let g:loaded_illuminate = 1
                            
    1              0.000010 if has('nvim-0.7.2') && get(g:, 'Illuminate_useDeprecated', 0) != 1
    1              0.000003 lua << EOF
                                if vim.fn.has('nvim-0.9') == 0 then
                                    -- fallback to nvim-treesitter modules
                                    local ok, ts = pcall(require, 'nvim-treesitter')
                                    if ok then
                                        ts.define_modules({
                                            illuminate = {
                                                module_path = 'illuminate.providers.treesitter',
                                                enable = true,
                                                disable = {},
                                                is_supported = require('nvim-treesitter.query').has_locals,
                                            }
                                        })
                                    end
                                end
                                require('illuminate.engine').start()
                                vim.api.nvim_create_user_command('IlluminatePause', require('illuminate').pause, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateResume', require('illuminate').resume, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateToggle', require('illuminate').toggle, { bang = true })
                                vim.api.nvim_create_user_command('IlluminatePauseBuf', require('illuminate').pause_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateResumeBuf', require('illuminate').resume_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateToggleBuf', require('illuminate').toggle_buf, { bang = true })
                                vim.api.nvim_create_user_command('IlluminateDebug', require('illuminate').debug, { bang = true })
                            
                                if not require('illuminate.config').disable_keymaps() then
                                    if not require('illuminate.util').has_keymap('n', '<a-n>') then
                                        vim.keymap.set('n', '<a-n>', require('illuminate').goto_next_reference, { desc = "Move to next reference" })
                                    end
                                    if not require('illuminate.util').has_keymap('n', '<a-p>') then
                                        vim.keymap.set('n', '<a-p>', require('illuminate').goto_prev_reference, { desc = "Move to previous reference" })
                                    end
                                    if not require('illuminate.util').has_keymap('o', '<a-i>') then
                                        vim.keymap.set('o', '<a-i>', require('illuminate').textobj_select)
                                    end
                                    if not require('illuminate.util').has_keymap('x', '<a-i>') then
                                        vim.keymap.set('x', '<a-i>', require('illuminate').textobj_select)
                                    end
                                end
                            EOF
                            
    1              0.000078 lua require('illuminate').set_highlight_defaults()
    1              0.000006 augroup vim_illuminate_autocmds
    1              0.000019     autocmd!
    1              0.000014     autocmd ColorScheme * lua require('illuminate').set_highlight_defaults()
    1              0.000001 augroup END
                            
    1              0.000003 finish
                            end
                            
                            " Highlight group(s) {{{
                            if !hlexists('illuminatedWord')
                              " this is for backwards compatibility
                              if !empty(get(g:, 'Illuminate_hl_link', ''))
                                exe get(g:, 'Illuminate_hl_link', '')
                              else
                                hi def link illuminatedWord cursorline
                              endif
                            endif
                            " }}}
                            
                            " Autocommands {{{
                            if has('autocmd')
                              augroup illuminated_autocmd
                                autocmd!
                                autocmd CursorMoved,InsertLeave * call illuminate#on_cursor_moved()
                                autocmd WinLeave,BufLeave * call illuminate#on_leaving_autocmds()
                                autocmd CursorMovedI * call illuminate#on_cursor_moved_i()
                                autocmd InsertEnter * call illuminate#on_insert_entered()
                              augroup END
                            else
                              echoerr 'Illuminate requires Vim compiled with +autocmd'
                              finish
                            endif
                            " }}}
                            
                            " Commands {{{
                            command! -nargs=0 -bang IlluminationDisable call illuminate#disable_illumination(<bang>0)
                            command! -nargs=0 -bang IlluminationEnable call illuminate#enable_illumination(<bang>0)
                            command! -nargs=0 -bang IlluminationToggle call illuminate#toggle_illumination(<bang>0)
                            " }}} Commands:
                            
                            " vim: foldlevel=1 foldmethod=marker

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/diffview.nvim/plugin/diffview.lua
Sourced 1 time
Total time:   0.054652
 Self time:   0.054652

count  total (s)   self (s)
                            if vim.g.diffview_nvim_loaded or not require("diffview.bootstrap") then
                              return
                            end
                            
                            vim.g.diffview_nvim_loaded = 1
                            
                            local lazy = require("diffview.lazy")
                            
                            ---@module "diffview"
                            local arg_parser = lazy.require("diffview.arg_parser") ---@module "diffview.arg_parser"
                            local diffview = lazy.require("diffview") ---@module "diffview"
                            
                            local api = vim.api
                            local command = api.nvim_create_user_command
                            
                            -- NOTE: Need this wrapper around the completion function becuase it doesn't
                            -- exist yet.
                            local function completion(...)
                              return diffview.completion(...)
                            end
                            
                            -- Create commands
                            command("DiffviewOpen", function(ctx)
                              diffview.open(arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion })
                            
                            command("DiffviewFileHistory", function(ctx)
                              local range
                            
                              if ctx.range > 0 then
                                range = { ctx.line1, ctx.line2 }
                              end
                            
                              diffview.file_history(range, arg_parser.scan(ctx.args).args)
                            end, { nargs = "*", complete = completion, range = true })
                            
                            command("DiffviewClose", function()
                              diffview.close()
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewFocusFiles", function()
                              diffview.emit("focus_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewToggleFiles", function()
                              diffview.emit("toggle_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewRefresh", function()
                              diffview.emit("refresh_files")
                            end, { nargs = 0, bang = true })
                            
                            command("DiffviewLog", function()
                              vim.cmd(("sp %s | norm! G"):format(
                                vim.fn.fnameescape(DiffviewGlobal.logger.outfile)
                              ))
                            end, { nargs = 0, bang = true })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/neogit/plugin/neogit.lua
Sourced 1 time
Total time:   0.003060
 Self time:   0.003060

count  total (s)   self (s)
                            local api = vim.api
                            
                            api.nvim_create_user_command("Neogit", function(o)
                              local neogit = require("neogit")
                              neogit.open(require("neogit.lib.util").parse_command_args(o.fargs))
                            end, {
                              nargs = "*",
                              desc = "Open Neogit",
                              complete = function(arglead)
                                local neogit = require("neogit")
                                return neogit.complete(arglead)
                              end,
                            })
                            
                            api.nvim_create_user_command("NeogitResetState", function()
                              require("neogit.lib.state")._reset()
                            end, { nargs = "*", desc = "Reset any saved flags" })
                            
                            api.nvim_create_user_command("NeogitLogCurrent", function(args)
                              local action = require("neogit").action
                              local path = vim.fn.expand(args.fargs[1] or "%")
                            
                              if args.range > 0 then
                                action("log", "log_current", { "-L" .. args.line1 .. "," .. args.line2 .. ":" .. path })()
                              else
                                action("log", "log_current", { "--", path })()
                              end
                            end, {
                              nargs = "?",
                              desc = "Open git log (current) for specified file, or current file if unspecified. Optionally accepts a range.",
                              range = "%",
                              complete = "file",
                            })
                            
                            api.nvim_create_user_command("NeogitCommit", function(args)
                              local commit = args.fargs[1] or "HEAD"
                              local CommitViewBuffer = require("neogit.buffers.commit_view")
                              CommitViewBuffer.new(commit):open()
                            end, {
                              nargs = "?",
                              desc = "Open git commit view for specified commit, or HEAD",
                            })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/plenary.nvim/plugin/plenary.vim
Sourced 1 time
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
                            
                            " Create command for running busted
    1              0.000034 command! -nargs=1 -complete=file PlenaryBustedFile
                                  \ lua require('plenary.test_harness').test_file([[<args>]])
                            
    1              0.000018 command! -nargs=+ -complete=file PlenaryBustedDirectory
                                  \ lua require('plenary.test_harness').test_directory_command([[<args>]])
                            
    1              0.000030 nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-hlslens/plugin/hlslens.vim
Sourced 1 time
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
                            " Actually, want to remove this file, but it will break change :(
    1              0.000030 if exists('g:loaded_nvim_hlslens')
                                finish
    1              0.000001 endif
                            
    1              0.000010 if !has('nvim-0.6.1')
                                call v:lua.vim.notify('nvim-hlslens failed to initialize, RTFM.')
                                finish
    1              0.000000 endif
                            
    1              0.000019 let g:loaded_nvim_hlslens = 1

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/LuaSnip/plugin/luasnip.lua
Sourced 1 time
Total time:   0.173303
 Self time:   0.173303

count  total (s)   self (s)
                            vim.filetype.add({
                            	extension = { snippets = "snippets" },
                            })
                            
                            local function silent_map(mode, lhs, rhs, desc)
                            	vim.keymap.set(mode, lhs, rhs, { silent = true, desc = desc or "" })
                            end
                            
                            silent_map("i", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("i", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("i", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("i", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("i", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            silent_map("n", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            silent_map("!", "<Plug>luasnip-delete-check", function()
                            	require("luasnip").unlink_current_if_deleted()
                            end, "LuaSnip: Removes current snippet from jumplist")
                            
                            silent_map("", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            silent_map("!", "<Plug>luasnip-expand-repeat", function()
                            	require("luasnip").expand_repeat()
                            end, "LuaSnip: Repeat last node expansion")
                            
                            silent_map("s", "<Plug>luasnip-expand-or-jump", function()
                            	require("luasnip").expand_or_jump()
                            end, "LuaSnip: Expand or jump in the current snippet")
                            silent_map("s", "<Plug>luasnip-expand-snippet", function()
                            	require("luasnip").expand()
                            end, "LuaSnip: Expand the current snippet")
                            silent_map("s", "<Plug>luasnip-next-choice", function()
                            	require("luasnip").change_choice(1)
                            end, "LuaSnip: Change to the next choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-prev-choice", function()
                            	require("luasnip").change_choice(-1)
                            end, "LuaSnip: Change to the previous choice from the choiceNode")
                            silent_map("s", "<Plug>luasnip-jump-next", function()
                            	require("luasnip").jump(1)
                            end, "LuaSnip: Jump to the next node")
                            silent_map("s", "<Plug>luasnip-jump-prev", function()
                            	require("luasnip").jump(-1)
                            end, "LuaSnip: Jump to the previous node")
                            
                            vim.api.nvim_create_user_command("LuaSnipUnlinkCurrent", function()
                            	require("luasnip").unlink_current()
                            end, { force = true })
                            
                            --stylua: ignore
                            vim.api.nvim_create_user_command("LuaSnipListAvailable", function()
                            	(require("luasnip.util.vimversion").ge(0,9,0) and vim.print or vim.pretty_print)(require("luasnip").available())
                            end, { force = true })
                            
                            require("luasnip.config")._setup()
                            
                            -- register these during startup so lazy_load will also load filetypes whose
                            -- events fired only before lazy_load is actually called.
                            -- (BufWinEnter -> lazy_load() wouldn't load any files without these).
                            vim.api.nvim_create_augroup("_luasnip_lazy_load", {})
                            vim.api.nvim_create_autocmd({ "BufWinEnter", "FileType" }, {
                            	callback = function(event)
                            		require("luasnip.loaders").load_lazy_loaded(tonumber(event.buf))
                            	end,
                            	group = "_luasnip_lazy_load",
                            })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/LuaSnip/plugin/luasnip.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000030 function! luasnip#expandable()
                            	return luaeval('require("luasnip").expandable()')
                            endfunction
                            
    1              0.000002 function! luasnip#expand_or_jumpable()
                            	return luaeval('require("luasnip").expand_or_jumpable()')
                            endfunction
                            
    1              0.000001 function! luasnip#expand_or_locally_jumpable()
                            	return luaeval('require("luasnip").expand_or_locally_jumpable()')
                            endfunction
                            
    1              0.000003 function! luasnip#locally_jumpable(direction)
                            	return luaeval('require("luasnip").locally_jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000001 function! luasnip#jumpable(direction)
                            	return luaeval('require("luasnip").jumpable(_A)', a:direction)
                            endfunction
                            
    1              0.000001 function! luasnip#choice_active()
                            	return luaeval('require("luasnip").choice_active()')
                            endfunction

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/blink.cmp/plugin/blink-cmp.lua
Sourced 1 time
Total time:   0.113217
 Self time:   0.113217

count  total (s)   self (s)
                            if vim.fn.has('nvim-0.11') == 1 and vim.lsp.config then
                              local user_caps = vim.lsp.config['*'].capabilities
                            
                              vim.lsp.config('*', {
                                capabilities = require('blink.cmp').get_lsp_capabilities(user_caps),
                              })
                            end
                            
                            -- Commands
                            local subcommands = {
                              status = function() vim.cmd('checkhealth blink.cmp') end,
                              build = function() require('blink.cmp.fuzzy.build').build() end,
                              ['build-log'] = function() require('blink.cmp.fuzzy.build').build_log() end,
                            }
                            vim.api.nvim_create_user_command('BlinkCmp', function(cmd)
                              local subcmd_name = cmd.fargs[1]
                              local subcmd = subcommands[subcmd_name]
                            
                              if subcmd then
                                subcmd()
                              else
                                vim.notify("[blink.cmp] invalid subcommand '" .. tostring(subcmd_name) .. "'", vim.log.levels.ERROR)
                              end
                            end, { nargs = 1, complete = function() return vim.tbl_keys(subcommands) end, desc = 'blink.cmp' })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-tree.lua/plugin/nvim-tree.lua
Sourced 1 time
Total time:   0.016467
 Self time:   0.016467

count  total (s)   self (s)
                            require("nvim-tree.commands").setup()

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-web-devicons/plugin/nvim-web-devicons.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    1              0.000024 if exists('g:loaded_devicons') | finish | endif
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
                            " TODO change so its easier to get
    1              0.000002 let g:nvim_web_devicons = 1
                            
    1              0.000004 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
    1              0.000003 let g:loaded_devicons = 1

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/dial.nvim/plugin/dial.lua
Sourced 1 time
Total time:   0.105903
 Self time:   0.105859

count  total (s)   self (s)
    1              0.000037 if vim.fn.exists "g:loaded_dial" == 1 then
                                return
                            end
                            
                            local cpo = vim.o.cpoptions
                            vim.cmd [[set cpo&vim]]
                            
                            vim.keymap.set("n", "<Plug>(dial-increment)", require("dial.map").inc_normal())
                            vim.keymap.set("n", "<Plug>(dial-decrement)", require("dial.map").dec_normal())
                            vim.keymap.set("n", "<Plug>(dial-g-increment)", require("dial.map").inc_gnormal())
                            vim.keymap.set("n", "<Plug>(dial-g-decrement)", require("dial.map").dec_gnormal())
                            vim.keymap.set("v", "<Plug>(dial-increment)", require("dial.map").inc_visual() .. "gv")
                            vim.keymap.set("v", "<Plug>(dial-decrement)", require("dial.map").dec_visual() .. "gv")
                            vim.keymap.set("v", "<Plug>(dial-g-increment)", require("dial.map").inc_gvisual() .. "gv")
                            vim.keymap.set("v", "<Plug>(dial-g-decrement)", require("dial.map").dec_gvisual() .. "gv")
                            
                            vim.o.cpoptions = cpo
                            vim.g.loaded_dial = 1

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/vimade/plugin/vimade.vim
Sourced 1 time
Total time:   0.057257
 Self time:   0.055281

count  total (s)   self (s)
    1              0.000020 if exists('g:vimade_loaded')
                              finish
    1              0.000001 endif
                            
    1              0.000005 let g:vimade_loaded = 1
                            
    1              0.000002 if !exists('g:vimade')
    1              0.000002   let g:vimade = {}
    1              0.000000 endif
                            
                            
                            ""Enables Vimade
    1              0.000011 command! VimadeEnable call vimade#Enable()
                            
                            ""Unfades all buffers, signs, and disables Vimade
    1              0.000002 command! VimadeDisable call vimade#Disable()
                            
                            ""Disables the current window
    1              0.000003 command! VimadeWinDisable call vimade#WinDisable()
                            
                            ""Disables the current buffer
    1              0.000002 command! VimadeBufDisable call vimade#BufDisable()
                            
                            ""Fades the current buffer
    1              0.000002 command! VimadeFadeActive call vimade#FadeActive()
                            "
                            ""Unfades the current buffer
    1              0.000003 command! VimadeUnfadeActive call vimade#UnfadeActive()
                            
                            ""Enables the current window
    1              0.000002 command! VimadeWinEnable call vimade#WinEnable()
                            
                            ""Enables the current buffer
    1              0.000002 command! VimadeBufEnable call vimade#BufEnable()
                            
                            ""Toggles Vimade between enabled and disabled states
    1              0.000002 command! VimadeToggle call vimade#Toggle()
                            
                            ""Prints debug information that should be included in bug reports
    1              0.000004 command! VimadeInfo echo json_encode(vimade#GetInfo())
                            
                            ""Recalculates all fades and redraws all inactive buffers and signs
    1              0.000002 command! VimadeRedraw call vimade#Redraw()
                            
                            ""Changes vimade_fadelevel to the {value} specified.  {value} can be between
                            "0.0 and 1.0
    1              0.000004 command! -nargs=1 VimadeFadeLevel call vimade#FadeLevel(<q-args>)
                            
                            ""Changes vimade_fadepriority to the {value} specified.  This can be useful
                            "when combining Vimade with other plugins that also highlight using matches
    1              0.000003 command! -nargs=1 VimadeFadePriority call vimade#FadePriority(<q-args>)
                            
                            ""Overrides the Folded highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideFolded call vimade#OverrideFolded()
                            
                            ""EXPERIMENTAL -- Overrides the SignColumn highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideSignColumn call vimade#OverrideSignColumn()
                            
                            ""EXPERIMENTAL -- Overrides the LineNr highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideLineNr call vimade#OverrideLineNr()
                            
                            ""EXPERIMENTAL -- Overrides the VertSplit highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideSplits call vimade#OverrideVertSplit()
                            
                            ""EXPERIMENTAL -- Overrides the NonText highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideNonText call vimade#OverrideNonText()
                            
                            ""EXPERIMENTAL -- Overrides the EndOfBuffer highlight by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideEndOfBuffer call vimade#OverrideEndOfBuffer()
                            
                            ""EXPERIMENTAL -- Overrides static highlights by creating a link to the Vimade base fade.
                            "This should produce acceptable results for colorschemes that include Folded
                            "highlights that are distracting in faded windows.
    1              0.000003 command! VimadeOverrideAll call vimade#OverrideAll()
                            
                            "" EXPERIMENTAL - Loads the current lua-only commands for Neovim (VimadeFocus & VimadeMark)
    1              0.000005 if has('nvim')
    1              0.045472   lua require('vimade.focus.commands')
    1              0.000013 endif
                            
    1              0.000486 let g:vimade_plugin_current_directory = resolve(expand('<sfile>:p:h').'/../lib')
                            
    1              0.000021 if (!exists('g:vimade.lazy') || !g:vimade.lazy) && !exists('g::vimade_loaded')
    1              0.000005   if v:vim_did_enter
    1   0.011093   0.009116     call vimade#Load()
                              else
                                augroup vimade
                                  au!
                                  au VimEnter * call vimade#Load()
                                augroup END
    1              0.000001   endif
    1              0.000006 endif

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim
Sourced 1 time
Total time:   0.001948
 Self time:   0.001067

count  total (s)   self (s)
    1              0.000024 let g:vimade_loaded = 1
    1              0.000008 function! vimade#Load()
                              " empty hook to initiate loading
                            endfunction
                            
    1              0.000002 function! vimade#Empty()
                            endfunction
                            
    1              0.000002 function! vimade#CreateGlobals()
                              "let g:vimade_lua_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'lua'
                              "let g:vimade_py_v2_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'python-v2'
                            
                              if !exists('g:vimade_running')
                                ""@setting vimade_running
                                "This flag is used to control whether or not vimade should be running.  This can be useful to toggle vimade during startup.  Alternatively, you may as also use VimadeDisable, VimadeEnable, call vimade#Disable, call vimade#Enable respectively
                            
                                let g:vimade_running = 1
                              endif
                              let g:vimade_paused = 0
                              let g:vimade_error_count = 0
                              let g:vimade_fade_active = 0
                              if !exists('g:vimade')
                                let g:vimade = {}
                              endif
                              if !exists('g:vimade_overlay')
                                let g:vimade_overlay = {}
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#SetupRenderer()
                              let l:next_renderer = g:vimade_active_renderer.name
                              if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
                                let l:next_renderer = 'lua'
                              else
                                if g:vimade_python_setup == 0
                                  call vimade#SetupPython()
                                endif
                                if g:vimade.renderer == 'auto'
                                  let l:next_renderer = 'python'
                                elseif g:vimade.renderer == 'python'
                                  let l:next_renderer = g:vimade.renderer
                                endif
                              endif
                              if l:next_renderer != g:vimade_active_renderer.name
                                try
                                  call vimade#UnhighlightAll()
                                catch
                                endtry
                                if l:next_renderer == 'lua'
                                  let g:vimade_active_renderer = s:lua_renderer
                                elseif l:next_renderer == 'python'
                                  let g:vimade_active_renderer = s:python_renderer
                                else
                                  let g:vimade_active_renderer = s:empty_renderer
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#SetupPython()
                              let g:vimade_python_setup = 1
                              " find proper command
                              if !exists('g:vimade_py_cmd')
                                call vimade#SetupPythonFeatures()
                                if g:vimade_features.has_python3
                                  let g:vimade_py_cmd = "py3"
                                elseif g:vimade_features.has_python
                                  let g:vimade_py_cmd = "py"
                                else
                                  return
                                endif
                                exec g:vimade_py_cmd  join([
                                      \ "import vim",
                                      \ "sys.path.append(vim.eval('g:vimade_plugin_current_directory'))",
                                      \ ], "\n")
                                silent doautocmd User Vimade#PythonReady
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#SetupPythonFeatures()
                              let g:vimade_features.has_python3 = has('python3')
                              let g:vimade_features.has_python = has('python')
                              let g:vimade_features.supports_python_renderer = g:vimade_features.has_python3 || g:vimade_features.has_python
                            endfunction
                            
    1              0.000001 function! vimade#GetFeatures()
                              if !exists('g:vimade_features')
                                let g:vimade_features = {}
                                let g:vimade_features.has_gui_running = has('gui_running')
                                let g:vimade_features.has_gui = has('gui')
                                let g:vimade_features.has_nvim = has('nvim')
                                let g:vimade_features.has_vimr = has('gui_vimr')
                                let g:vimade_features.has_timer_start = exists('*timer_start')
                                let g:vimade_features.has_sign_getplaced = exists('*sign_getplaced')
                            
                                if g:vimade_features.has_nvim
                                  " Below are for lua renderer
                            
                                  " Required:
                                  " Required: nvim_win_set_hl_ns
                                  let g:vimade_features.has_nvim_win_set_hl_ns = exists('*nvim_win_set_hl_ns')
                                  " Required:
                                  " Either (preferred) nvim_get_hl
                                  let g:vimade_features.has_nvim_get_hl = exists('*nvim_get_hl')
                                  " Or (fallback) nvim__get_hl_defs + nvim_get_hl_by_name (assume supported)
                                  let g:vimade_features.has__nvim_get_hl_defs = exists('*nvim__get_hl_defs')
                                  
                                  "Optional:
                                  " preferred but not required nvim_get_hl_ns
                                  " fallback is try and manually track (probably will have conflicts with some plugins)
                                  let g:vimade_features.has_nvim_get_hl_ns = exists('*nvim_get_hl_ns')
                            
                                  let g:vimade_features.supports_lua_renderer = (g:vimade_features.has_nvim_get_hl || g:vimade_features.has__nvim_get_hl_defs) && g:vimade_features.has_nvim_win_set_hl_ns
                                  let g:vimade_features.has_wincolor = 0
                                  let g:vimade_features.has_gui_version = 0
                                else
                                  let g:vimade_features.has_nvim_win_set_hl_ns = 0
                                  let g:vimade_features.has_nvim_get_hl = 0
                                  let g:vimade_features.has__nvim_get_hl_defs = 0
                                  let g:vimade_features.has_nvim_get_hl_ns = 0
                                  let g:vimade_features.supports_lua_renderer = 0
                                  let g:vimade_features.has_wincolor = exists('&wincolor')
                                  let g:vimade_features.has_gui_version = execute('version')=~"GUI version"
                                endif
                            
                                try
                                  sign define Vimade_Test text=1
                                  sign place 1 group=vimade line=1 name=Vimade_Test priority=100
                                  sign unplace 1 group=vimade
                                  let g:vimade_features.has_sign_group = 1
                                  let g:vimade_features.has_sign_priority = 1
                                catch
                                  let g:vimade_features.has_sign_group = 0
                                  let g:vimade_features.has_sign_priority = 0
                                endtry
                              endif
                              return g:vimade_features
                            endfunction
                            
    1              0.000001 function! vimade#GetDefaults()
                              if !exists('g:vimade_defaults')
                            
                                ""The vimade configuration object
                                "@setting vimade
                                
                                let g:vimade_defaults = {'$extended': 1}
                            
                                ""@setting vimade.renderer
                                "Select the renderer to use for vimade window/buffer highlights.
                                "If not specificed, defaults to 'auto'. It is recommended to leave this
                                "option set to 'auto', 'lua', or 'python'.
                                "Current options are:
                                "  - 'auto' - Uses lua renderer if supported on your Neovim version. Otherwise, this option will automatically fallback to 'python'.
                                "  - 'python' - Uses a new high performance renderer compatible with Vim and Neovim
                            
                                let g:vimade_defaults.renderer = 'auto'
                            
                                ""@setting vimade.fadelevel
                                "Supported:     lua, python
                                "Amount of fading applied between text and basebg.  0 will make the text the same color as the background and 1 applies no fading.  The default value is 0.4.  If you are using terminal, you may need to tweak this value to get better results.
                            
                                let g:vimade_defaults.fadelevel = 0.4
                                
                                ""@setting vimade.tint
                                "Supported:     lua, python
                                "Amount and type of tinting to apply. Unset by default.  This param is currently under maintainence. This function can currently be either a config object such as:
                                "{'fg':{'rgb':[255,0,0], 'intensity': 0.5, 'type': 'MIX'}, 'bg':{'rgb':[255,0,0], 'type': 'REPLACE'}, 'sp': {'rgb':[255,0,0], 'type': 'MIX'}}
                                "The fields in the object are completely optional (you can peform a bg-only or fg-only tint)
                                "You can also set g:vimade.tint to a lua or python function that returns the tint object.
                                "Lua
                                "require('vimade').setup({
                                " tint = function (win)
                                "   return {
                                "    fg = {
                                "      rgb={255,0,0},
                                "      intensity = 0.75,
                                "    },
                                "  }
                                " end
                                "})
                                "Python
                                "from vimade.v2 import vimade
                                "vimade.setup({
                                " 'tint': lambda a,test : {'fg':{'rgb':[255,0,0], 'intensity': 0.5}}
                                "})
                            
                                ""@setting vimade.basebg
                                "Supported:     lua, python
                                "basebg can be either be six digit hexidecimal color, rgb array [0-255,0-255,0-255], or cterm code (in terminal).  basebg is used as the color that text is faded against.  You can override this config with another hexidecimal color.  A cool feature of basebg is to use it to change the tint of faded text even if its not your background!
                            
                                let g:vimade_defaults.basebg = ''
                                "
                                ""@setting vimade.recipe
                                "Supported:     ['default', {}], ['minimalist', {}], ['duo', {'animate': v:false}]
                                " The second argument in the array overrides the recipe settings (e.g.
                                " {'animate': v:true})
                                " May also specify recipe as just 'default' or ['default']
                            
                                " unset - but automatically picked up if user changes and has not set via
                                " overlay
                                let g:vimade_defaults.recipe = 'default'
                                let g:vimade.__recipe = 'default' 
                                let g:__vimade_recipe_applied = 0 
                            
                                ""@setting vimade.ncmode
                                "Supported:     lua, python
                                "Whether to fade active windows or buffers.  Options are 'windows' or 'buffers'.  Defaults to 'buffers'.
                            
                                let g:vimade_defaults.ncmode = 'buffers'
                            
                                "Can be set via vim object
                                ""@setting vimade.blocklist
                                "Supported:     lua, python
                                "TODO docs
                            
                                ""@setting vimade.link
                                "Supported:     lua, python
                                "Controls whether or not diffs will fade/unfade together.
                                "TODO docs
                            
                            
                                ""@setting vimade.groupdiff
                                "Supported:     lua, python
                                "Controls whether or not diffs will fade/unfade together.  If you want diffs
                                "to be treated separately, set this value to 0. Default is 1
                            
                                let g:vimade_defaults.groupdiff = 1
                            
                                ""@setting vimade.groupscrollbind
                                "Supported:     lua, python
                                "Controls whether or not scrollbound windows will fade/unfade together.  If
                                "you want scrollbound windows to unfade together, set this to 1.  Default is
                                "0.
                                
                                let g:vimade_defaults.groupscrollbind = 0
                            
                                ""@setting vimade.enablefocusfading
                                "Supported:     lua, python
                                "Fades the current active window on focus blur and unfades when focus gained.
                                "This can be desirable when switching applications or TMUX splits.
                                "* Install 'tmux-plugins/vim-tmux-focus-events' using your preferred plugin manager
                                "* Add `set -g focus-events on` to your tmux.conf
                                "* Neovim should work at this point, If you are using Vim you may also need the following snippet to the very end of your vimrc
                                ">
                                "  if has('gui_running') == 0 && has('nvim') == 0
                                "     call feedkeys(":silent execute '!' | redraw!\<CR>")
                                "  endif
                                "<
                            
                                let g:vimade_defaults.enablefocusfading = 0
                               
                                ""@setting vimade.normalid
                                "Supported:     lua, python
                                "If not specified, the normalid is determined when vimade is first loaded.  normalid provides the id of the "Normal" highlight which is used to calculate fading.  You can override this config with another highlight group.
                                "You shouldn't really ever need to modify this.
                            
                                let g:vimade_defaults.normalid = ''
                            
                                ""@setting vimade.normalncid
                                "Supported:     lua, python
                                "If not specified, the normalncid is determined when vimade is first loaded.  normalncid provides the id of the "NormalNC" highlight which is used to calculate fading for inactive buffers in NVIM.  You can override this config with another highlight group.
                                "You shouldn't really ever need to modify this.
                            
                                let g:vimade_defaults.normalncid = ''
                            
                                ""@setting vimade.checkinterval
                                "Supported:     lua, python
                                "The amount of time in milliseconds that vimade should check the screen for changes.  This config is mainly used to detect resize and scroll changes that occur on inactive windows. Checkinterval does nothing on gvim, if you want to control the refresh time, see 'h updatetime'. Default is 1000.  
                            
                                let g:vimade_defaults.checkinterval = 1000
                            
                                ""@setting vimade.usecursorhold
                                "Supported:     lua, python
                                "Disables the timer running in the background and instead relies `OnCursorHold` and `updatetime` (see h:updatetime).  The default value is `0` except on older Windows GVIM, which defaults to `1` due to the timer breaking movements.  If you find that the timer is causing performance problems or other issues you can disable it by setting this option to `1`. 
                            
                                let g:vimade_defaults.usecursorhold = g:vimade_features.has_gui_running && !g:vimade_features.has_nvim && g:vimade_features.has_gui_version
                            
                                ""@setting vimade.basegroups
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting that specifies the basegroups/built-in highlight groups that will be faded using winhl when switching windows
                            
                                let g:vimade_defaults.basegroups = ['Folded', 'Search', 'SignColumn', 'CursorLine', 'CursorLineNr', 'DiffAdd', 'DiffChange', 'DiffDelete', 'DiffText', 'FoldColumn', 'Whitespace', 'NonText', 'SpecialKey', 'Conceal', 'EndOfBuffer', 'WinSeparator', 'LineNr', 'LineNrAbove', 'LineNrBelow']
                            
                                ""@setting vimade.enablebasegroups
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting.  Enabled by default and allows basegroups/built-in highlight fading using winhl.  This allows fading of built-in highlights such as Folded, Search, etc.
                            
                                let g:vimade_defaults.enablebasegroups = 1
                            
                            
                                ""@setting vimade.enabletreesitter
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting.  Disabled by default and hooks vimade into the internals of treesitter.
                            
                                let g:vimade_defaults.enabletreesitter = 0
                            
                                ""@setting vimade.enablesigns
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "Enabled by default for vim/nvim versions that support sign priority and causes signs to be faded when switching buffers.
                                "Only visible signs are faded. This feature can cause performance issues
                                "on older nvim/vim versions that don't support sign priority. 
                                "Use signsretentionperiod to control the duration that vimade checks for sign updates after switching buffers.
                            
                                let g:vimade_defaults.enablesigns = g:vimade_features.has_sign_priority
                            
                                ""@setting vimade.signsid
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "The starting id that Vimade should use when creating new signs. By
                                "default Vim requires numeric values to create signs and its possible that
                                "collisions may occur between plugins.  If you need to override this value for
                                "compatibility, please open an issue as well.  Default is 13100.
                            
                                let g:vimade_defaults.signsid = 13100
                            
                                ""@setting vimade.signsretentionperiod
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                " *python*: Serves no purpose on lua renderer.
                                "Amount of time in milliseconds that faded buffers should be tracked for sign changes.  Default value is 4000.
                            
                                let g:vimade_defaults.signsretentionperiod = 4000
                            
                                ""@setting vimade.signspriority
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "Controls the signs fade priority.
                                "You may need to change this value if you find that not all signs are fading properly.
                                "Please also open a defect if you need to tweak this value as Vimade strives to minimize manual configuration where possible.
                                "Default is 31.
                            
                                let g:vimade_defaults.signspriority = 31
                            
                                ""@setting vimade.fademinimap
                                "Supported:     lua, python
                                "Enables fading for `severin-lemaignan/vim-minimap`. Setting vimade.fademinimap to
                                "0 disables the special fade.  Default is 1.
                            
                                let g:vimade_defaults.fademinimap = 1
                            
                                ""@setting vimade.fadepriority
                                "Supported:     python
                                "lua uses namespaces and doesn't require priority settings
                                "Controls the highlighting priority.
                                "You may want to tweak this value to make Vimade play nicely with other highlighting plugins and behaviors.
                                "For example, if you want hlsearch to show results on all buffers, you may want to lower this value to 0.
                                "Default is 10.
                            
                                let g:vimade_defaults.fadepriority = 10
                            
                                ""@setting vimade.disablebatch
                                "Supported:     python
                                "Disables interprocess batching. Useful if you are seeing issues and need to debug an error.
                            
                                let g:vimade_defaults.disablebatch = 0
                            
                                let g:vimade_defaults_keys = keys(g:vimade_defaults)
                                if exists('g:vimade_usecursorhold')
                                  let g:vimade.usecursorhold = g:vimade_usecursorhold
                                endif
                              endif
                              return g:vimade_defaults
                            endfunction
                            
    1              0.000002 function! vimade#Enable()
                              "enable vimade
                              let g:vimade_running = 1
                              if !exists('g:vimade_init')
                                call vimade#Init()
                              endif
                              call vimade#DeferredCheckWindows()
                              call vimade#StartTimer()
                            endfunction
                            
    1              0.000002 function! vimade#WinEnable()
                              if exists('w:vimade_disabled')
                                unlet w:vimade_disabled
                                call vimade#DeferredCheckWindows()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#WinDisable()
                              let w:vimade_disabled=1
                              call vimade#DeferredCheckWindows()
                            endfunction
                            
    1              0.000001 function! vimade#BufEnable()
                              if exists('b:vimade_disabled')
                                unlet b:vimade_disabled
                                call vimade#DeferredCheckWindows()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#BufDisable()
                              let b:vimade_disabled=1
                              call vimade#DeferredCheckWindows()
                            endfunction
                            
    1              0.000001 function! vimade#Disable()
                              if winnr() == 0
                                return
                              endif
                              "disable vimade
                              let g:vimade_running = 0
                              call vimade#StopTimer()
                              call g:vimade_active_renderer.disable()
                            endfunction
                            
    1              0.000002 function! vimade#UnhighlightAll()
                              if winnr() == 0
                                return
                              endif
                              call g:vimade_active_renderer.disable()
                            endfunction
                            
    1              0.000001 function! vimade#Toggle()
                              "toggle enabled state
                              if g:vimade_running
                                call vimade#Disable()
                              else
                                call vimade#Enable()
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#Override(name)
                              execute('hi! link '. a:name . ' vimade_0')
                            endfunction
                            
    1              0.000001 function! vimade#OverrideFolded()
                              call vimade#Override('Folded')
                            endfunction
                            
    1              0.000002 function! vimade#OverrideSignColumn()
                              call vimade#Override('SignColumn')
                            endfunction
                            
    1              0.000001 function! vimade#OverrideLineNr()
                              call vimade#Override('LineNr')
                            endfunction
                            
    1              0.000001 function! vimade#OverrideVertSplit()
                              call vimade#Override('VertSplit')
                            endfunction
                            
    1              0.000002 function! vimade#OverrideEndOfBuffer()
                              call vimade#Override('EndOfBuffer')
                            endfunction
                            
    1              0.000002 function! vimade#OverrideNonText()
                              call vimade#Override('NonText')
                            endfunction
                            
    1              0.000001 function! vimade#OverrideAll()
                              call vimade#OverrideFolded()
                              call vimade#OverrideSignColumn()
                              call vimade#OverrideLineNr()
                              call vimade#OverrideVertSplit()
                              call vimade#OverrideNonText()
                              call vimade#OverrideEndOfBuffer()
                            endfunction
                            
    1              0.000001 function! vimade#Pause()
                              let g:vimade_paused=1
                            endfunction
                            
    1              0.000001 function! vimade#Unpause()
                              let g:vimade_paused=0
                            endfunction
                            
    1              0.000001 function! vimade#FocusGained()
                              call vimade#UpdateState()
                              call vimade#Unpause()
                              call vimade#InvalidateSigns()
                              let enablefocusfading = vimade#GetMaybeFromOverlay('enablefocusfading')
                              if enablefocusfading
                                call vimade#UnfadeActive()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#FocusLost()
                              let enablefocusfading = vimade#GetMaybeFromOverlay('enablefocusfading')
                              if enablefocusfading
                                call vimade#FadeActive()
                              endif
                              call vimade#Pause()
                            endfunction
                            
    1              0.000001 function! vimade#InvalidateSigns()
                              "prevent if inside popup window
                              if winnr() == 0
                                return
                              endif
                              if g:vimade_running && g:vimade_paused == 0
                                call g:vimade_active_renderer.softInvalidateSigns()
                                call vimade#DeferredCheckWindows()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#Recalculate()
                              if g:vimade_running && g:vimade_paused == 0
                                call g:vimade_active_renderer.recalculate()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#Redraw()
                              "prevent if inside popup window
                              if winnr() == 0
                                return
                              endif
                              if g:vimade_running && g:vimade_paused == 0
                                call g:vimade_active_renderer.redraw()
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#GetSigns (bufnr, rows)
                              let signs = get(getbufinfo(a:bufnr)[0],'signs',[])
                              let result = []
                              let g:rows = a:rows
                              for sign in signs
                                if has_key(a:rows, sign['lnum'])
                                  call add(result, sign)
                                endif
                              endfor
                              return result
                            endfunction
                            
    1              0.000001 function! vimade#GetInfo()
                              "get debug info
                              call g:vimade_active_renderer.getInfo()
                              return {
                                  \ 'version': '0.1.0',
                                  \ 'config': g:vimade,
                                  \ 'renderer': g:vimade_renderer_info,
                                  \ 'features': g:vimade_features, 
                                  \ 'other': {
                                    \ 'normal_id': g:vimade.normalid,
                                    \ 'normal_hi': vimade#GetHi(g:vimade.normalid),
                                    \ 'syntax': &syntax,
                                    \ 'colorscheme': execute(':colorscheme'),
                                    \ 'background': &background,
                                    \ 'vimade_py_cmd': (exists('g:vimade_py_cmd') ? g:vimade_py_cmd: 0),
                                    \ 'vimade_running': g:vimade_running,
                                    \ 'vimade_paused': g:vimade_paused,
                                    \ 'vimade_error_count': g:vimade_error_count,
                                    \ 'vimade_timer': exists('g:vimade_timer') ? g:vimade_timer : -1,
                                    \ 'vimade_loaded': g:vimade_loaded,
                                    \ 't_Co': &t_Co,
                                  \ }
                              \ }
                            endfunction
                            
    1              0.000002 function! vimade#FadeLevel(level)
                              let g:vimade.fadelevel = a:level
                              call vimade#DeferredCheckWindows()
                            endfunction
                            
    1              0.000002 function! vimade#FadePriority(priority)
                              let g:vimade.fadepriority = a:priority
                              call vimade#DeferredCheckWindows()
                            endfunction
                            
    1              0.000002 function! vimade#DeferredCheckWindows()
                              if g:vimade_features.has_timer_start
                                " only disable the deferred on animation for lua (lua doesn't
                                " only_these_windows)
                                if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
                                  return
                                endif
                                let g:vimade_deferred_timer = timer_start(1, 'vimade#DeferredTick')
                              else
                                return vimade#CheckWindows()
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#DeferredTick(num)
                              unlet g:vimade_deferred_timer
                              call vimade#Tick(0)
                            endfunction
                            
    1              0.000001 function! vimade#CheckWindows()
                              call vimade#UpdateState()
                              "prevent if inside popup window
                              " TODO: confirm if this is needed in newer renderers, which perform
                              " significantly better
                              if winnr() == 0 || pumvisible() 
                                return
                              endif
                              if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
                                call g:vimade_active_renderer.update()
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#StartAnimationTimer()
                              if g:vimade_features.has_timer_start && !exists('g:vimade_animation_running')
                                let g:vimade_animation_running = 1
                                if !exists('g:vimade_animation_timer')
                                  let g:vimade_animation_timer = timer_start(16, 'vimade#DoAnimations', {'repeat': -1})
                                else
                                  call timer_pause(g:vimade_animation_timer, 0)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#DoAnimations(val)
                              unlet g:vimade_animation_running
                              call timer_pause(g:vimade_animation_timer, 1)
                              if g:vimade_running && getcmdwintype() == ''
                                call g:vimade_active_renderer.animate()
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#softInvalidateBuffer(bufnr)
                              "prevent if inside popup window
                              if winnr() == 0
                                return
                              endif
                              "Don't check paused condition because the application may have not been regained and triggered FocusGained event
                              if g:vimade_running
                                call g:vimade_active_renderer.softInvalidateBuffer()
                              endif
                              call vimade#DeferredCheckWindows()
                            endfunction
                            
    1              0.000001 function! vimade#UpdateEvents()
                              augroup vimade
                                  au!
                                  au VimLeave * call vimade#Disable()
                                  au FocusGained * call vimade#FocusGained()
                                  au FocusLost * call vimade#FocusLost()
                                  " TODO neovim is broken in many scenarios in v0.10. Python logic is not
                                  " executed properly when called directly off and autoevent. This is
                                  " easily reproduceable when using netrw...
                                  au WinEnter,BufEnter * call vimade#DeferredCheckWindows()
                                  au OptionSet diff call vimade#DeferredCheckWindows()
                                  au ColorScheme * call vimade#Redraw()
                                  au FileChangedShellPost * call vimade#softInvalidateBuffer(expand("<abuf>"))
                                  let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
                                  if usecursorhold
                                    au CursorHold,CursorHoldI * call vimade#DeferredCheckWindows()
                                    au VimResized * call vimade#DeferredCheckWindows()
                                  endif
                              augroup END
                            endfunction
                            
    1              0.000001 function! vimade#ExtendState()
                              for prop in g:vimade_defaults_keys
                                if !has_key(g:vimade, prop)
                                  let g:vimade[prop] = g:vimade_defaults[prop]
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! vimade#GetMaybeFromOverlay(field)
                              if exists('g:vimade_overlay.' .. a:field)
                                return get(g:vimade_overlay, a:field)
                              else
                                return get(g:vimade, a:field)
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#UpdateState()
                              if !exists('g:vimade')
                                let g:vimade = {}
                              endif
                              if !has_key(g:vimade, '$extended')
                                call vimade#ExtendState()
                              endif
                              let l:recipe = get(g:vimade, 'recipe')
                              if l:recipe isnot g:vimade.__recipe
                                let g:vimade.__recipe = l:recipe
                                let g:__vimade_recipe_applied = 0
                              endif
                              let normalid = vimade#GetMaybeFromOverlay('normalid')
                              if normalid == "" || normalid == 0 || normalid == v:null
                                let g:vimade.normalid = hlID('Normal')
                              endif
                              let normalncid = vimade#GetMaybeFromOverlay('normalncid')
                              if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
                                let g:vimade.normalncid = hlID('NormalNC')
                              endif
                              let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
                              if usecursorhold != g:vimade_last.usecursorhold
                                let g:vimade_last.usecursorhold = usecursorhold
                                if usecursorhold
                                  call vimade#StopTimer()
                                else
                                  call vimade#StartTimer()
                                endif
                                call vimade#UpdateEvents()
                              endif
                              let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
                              if checkinterval != g:vimade_last.checkinterval
                                let g:vimade_last.checkinterval = checkinterval
                                call vimade#StopTimer()
                                call vimade#StartTimer()
                              endif
                              let g:vimade.__background = &background
                              let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
                              let g:vimade.__termguicolors = &termguicolors
                              call vimade#SetupRenderer()
                            endfunction
                            
    1              0.000002 function! vimade#Tick(num)
                              try
                                call vimade#CheckWindows()
                              catch
                                let g:vimade_error_count += 1
                                if g:vimade_error_count >= 3
                                  let g:vimade_error_count = 0
                                  try
                                    VimadeDisable
                                  catch
                                    let g:vimade_running = 0
                                  endtry
                                endif
                                throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
                              endtry
                            endfunction
                            
    1              0.000002 function! vimade#BypassPause(fn)
                              if g:vimade_paused
                                call vimade#Unpause()
                                call a:fn()
                                call vimade#Pause()
                              else
                                call a:fn()
                              endif
                            endfunction
                            
    1              0.000002 function! vimade#FadeActive()
                              "immediately fade current buffer
                              "deferred shouldn't be used here due to usage of pause in tmux flow
                              let g:vimade_fade_active=1
                              call vimade#BypassPause(function('vimade#CheckWindows'))
                            endfunction
                            
    1              0.000001 function! vimade#UnfadeActive()
                              "immediately unfade current buffer
                              "deferred shouldn't be used here due to usage of pause in tmux flow
                              let g:vimade_fade_active=0
                              call vimade#BypassPause(function('vimade#CheckWindows'))
                            endfunction
                            
    1              0.000001 function! vimade#GetNvimHi(id)
                              let tid = synIDtrans(a:id)
                              if tid > 0
                                let norgb = nvim_get_hl_by_id(tid, 0)
                                let rgb = nvim_get_hl_by_id(tid, 1)
                                return [get(norgb, 'foreground', -1), get(norgb, 'background', -1), get(rgb, 'foreground', -1), get(rgb, 'background', -1), get(rgb, 'special', -1)]
                              endif
                              return [-1,-1,-1,-1,-1]
                            endfunction
                            
    1              0.000001 function! vimade#GetHi(id)
                              "resolve root linkedTo id
                              let tid = synIDtrans(a:id)
                              return [synIDattr(tid, 'fg#'), synIDattr(tid, 'bg#'), synIDattr(tid, 'sp#')]
                            endfunction
                            
    1              0.000002 function! vimade#GetVisibleRows(startRow, endRow)
                              let l:row = a:startRow
                              let l:result = []
                              let l:rows = 0
                              let l:target_rows = a:endRow - a:startRow
                              while l:rows <= l:target_rows
                                let l:fold = foldclosedend(l:row)
                                call add(l:result, [l:row, l:fold])
                                if l:fold == -1
                                  let l:row += 1
                                else
                                  let l:row = l:fold + 1
                                endif
                                let l:rows += 1
                              endwhile
                              return l:result
                            endfunction
                            
    1              0.000001 function! vimade#StartTimer()
                              "timer is disabled when usecursorhold=1
                              let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
                              if !usecursorhold && !exists('g:vimade_timer') && g:vimade_running
                                let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
                                let g:vimade_timer = timer_start(checkinterval, 'vimade#Tick', {'repeat': -1})
                              endif
                            endfunction
    1              0.000001 function! vimade#StopTimer()
                              if exists('g:vimade_timer')
                                call timer_stop(g:vimade_timer)
                                unlet g:vimade_timer
                              endif
                            endfunction
                            
    1              0.000001 function! vimade#Init()
                              let l:already_running = 0
                              if exists('g:vimade_init')
                                let l:already_running = 1
                              endif
                              let g:vimade_init = 1
                              call vimade#CreateGlobals()
                              call vimade#GetFeatures()
                              call vimade#GetDefaults()
                              call vimade#ExtendState()
                              call vimade#UpdateEvents()
                            
                              let g:vimade_last = extend({}, g:vimade)
                            
                              "check immediately
                              if l:already_running == 0
                                call vimade#DeferredCheckWindows()
                              else
                                call vimade#Redraw()
                              endif
                              call vimade#StartTimer()
                            
                              "run the timer once during startup
                              "we use try here to possibly support vim 7
                              let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
                              if usecursorhold
                                let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
                                try
                                  call timer_start(checkinterval, 'vimade#Tick')
                                catch
                                endtry
                              endif
                            endfunction
                            
                            " Variables
    1              0.000004 let g:vimade_eval_ret = []
    1              0.000003 let g:vimade_active_renderer = 0
    1              0.000002 let g:vimade_python_setup = 0
                            
                            "Empty Renderer START
    1              0.000035 let s:empty_renderer = {
                                \ 'name': 'empty',
                                \ 'getInfo': function('vimade#Empty'),
                                \ 'recalculate': function('vimade#Empty'),
                                \ 'redraw': function('vimade#Empty'),
                                \ 'disable': function('vimade#Empty'),
                                \ 'update': function('vimade#Empty'),
                                \ 'softInvalidateBuffer': function('vimade#Empty'),
                                \ 'softInvalidateSigns': function('vimade#Empty'),
                                \ }
                            "Empty Renderer END
                            "
    1              0.000003 let g:vimade_active_renderer = s:empty_renderer 
                            
                            
    1              0.000007 function! s:Recalculate_Lua()
                              lua require('vimade').redraw()
                            endfunction
    1              0.000002 function! s:Redraw_Lua()
                              lua require('vimade').redraw()
                            endfunction
    1              0.000001 function! s:Disable_Lua()
                              lua require('vimade').disable()
                            endfunction
    1              0.000001 function! s:Update_Lua()
                              lua require('vimade').update()
                            endfunction
    1              0.000001 function! s:Animate_Lua()
                              lua require('vimade').animate()
                            endfunction
    1              0.000002 function! s:SoftInvalidateBuffer_Lua()
                              lua require('vimade').softInvalidateBuffer()
                            endfunction
    1              0.000002 function! s:SoftInvalidateSigns_Lua()
                              " empty
                            endfunction
    1              0.000001 function! s:GetInfo_Lua()
                              lua vim.g.vimade_renderer_info = require('vimade').getInfo()
                            endfunction
    1              0.000040 let s:lua_renderer = {
                              \ 'name': 'lua',
                              \ 'animate': function('s:Animate_Lua'),
                              \ 'getInfo': function('s:GetInfo_Lua'),
                              \ 'recalculate': function('s:Recalculate_Lua'),
                              \ 'redraw': function('s:Redraw_Lua'),
                              \ 'disable': function('s:Disable_Lua'),
                              \ 'update': function('s:Update_Lua'),
                              \ 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Lua'),
                              \ 'softInvalidateSigns': function('s:SoftInvalidateSigns_Lua'),
                              \ }
                            " Lua Renderer END
                            
                            " Python Renderer START
    1              0.000002 function! s:GetInfo_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; import vim; vim.vars['vimade_renderer_info'] = bridge.getInfo()"
                            endfunction
    1              0.000002 function! s:Recalculate_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.recalculate()"
                            endfunction
    1              0.000002 function! s:Redraw_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.disable(); bridge.recalculate()"
                              call vimade#CheckWindows()
                            endfunction
    1              0.000002 function! s:Disable_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.disable()"
                            endfunction
    1              0.000002 function! s:Update_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.update()"
                            endfunction
    1              0.000001 function! s:Animate_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.animate()"
                            endfunction
    1              0.000002 function! s:SoftInvalidateBuffer_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.invalidate()"
                            endfunction
    1              0.000018 function! s:SoftInvalidateSigns_Python()
                              exec g:vimade_py_cmd "from vimade import bridge; bridge.invalidate()"
                            endfunction
    1              0.000039 let s:python_renderer = {
                              \ 'name': 'python',
                              \ 'animate': function('s:Animate_Python'),
                              \ 'getInfo': function('s:GetInfo_Python'),
                              \ 'recalculate': function('s:Recalculate_Python'),
                              \ 'redraw': function('s:Redraw_Python'),
                              \ 'disable': function('s:Disable_Python'),
                              \ 'update': function('s:Update_Python'),
                              \ 'softInvalidateBuffer': function('s:SoftInvalidateBuffer_Python'),
                              \ 'softInvalidateSigns': function('s:SoftInvalidateSigns_Python'),
                              \ }
                            " Python Renderer END
                            
    1   0.000902   0.000021 call vimade#Init()

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/autoload/provider/clipboard.vim
Sourced 1 time
Total time:   0.000666
 Self time:   0.000591

count  total (s)   self (s)
                            " The clipboard provider uses shell commands to communicate with the clipboard.
                            " The provider function will only be registered if a supported command is
                            " available.
                            
    1              0.000028 if exists('g:loaded_clipboard_provider')
                              finish
    1              0.000001 endif
                            " Default to 0.  provider#clipboard#Executable() may set 2.
                            " To force a reload:
                            "   :unlet g:loaded_clipboard_provider
                            "   :runtime autoload/provider/clipboard.vim
    1              0.000008 let g:loaded_clipboard_provider = 0
                            
    1              0.000003 let s:copy = {}
    1              0.000001 let s:paste = {}
    1              0.000001 let s:clipboard = {}
                            
                            " When caching is enabled, store the jobid of the xclip/xsel process keeping
                            " ownership of the selection, so we know how long the cache is valid.
    1              0.000006 let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
                            
    1              0.000007 function! s:selection.on_exit(jobid, data, event) abort
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
                              if self.owner == a:jobid
                                let self.owner = 0
                              endif
                              " Don't print if exit code is >= 128 ( exit is 128+SIGNUM if by signal (e.g. 143 on SIGTERM))
                              if a:data > 0 && a:data < 128
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
                              endif
                            endfunction
                            
    1              0.000007 let s:selections = { '*': s:selection, '+': copy(s:selection) }
                            
    1              0.000002 function! s:try_cmd(cmd, ...) abort
                              let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
                              if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
                              endif
                              return out
                            endfunction
                            
                            " Returns TRUE if `cmd` exits with success, else FALSE.
    1              0.000001 function! s:cmd_ok(cmd) abort
                              call system(a:cmd)
                              return v:shell_error == 0
                            endfunction
                            
    1              0.000001 function! s:split_cmd(cmd) abort
                              return (type(a:cmd) == v:t_string) ? split(a:cmd, " ") : a:cmd
                            endfunction
                            
    1              0.000001 function! s:set_osc52() abort
                              let s:copy['+'] = v:lua.require'vim.ui.clipboard.osc52'.copy('+')
                              let s:copy['*'] = v:lua.require'vim.ui.clipboard.osc52'.copy('*')
                              let s:paste['+'] = v:lua.require'vim.ui.clipboard.osc52'.paste('+')
                              let s:paste['*'] = v:lua.require'vim.ui.clipboard.osc52'.paste('*')
                              return 'OSC 52'
                            endfunction
                            
    1              0.000001 function! s:set_pbcopy() abort
                              let s:copy['+'] = ['pbcopy']
                              let s:paste['+'] = ['pbpaste']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              let s:cache_enabled = 0
                              return 'pbcopy'
                            endfunction
                            
    1              0.000001 function! s:set_wayland() abort
                              let s:copy['+'] = ['wl-copy', '--type', 'text/plain']
                              let s:paste['+'] = ['wl-paste', '--no-newline']
                              let s:copy['*'] = ['wl-copy', '--primary', '--type', 'text/plain']
                              let s:paste['*'] = ['wl-paste', '--no-newline', '--primary']
                              return 'wl-copy'
                            endfunction
                            
    1              0.000001 function! s:set_wayclip() abort
                              let s:copy['+'] = ['waycopy']
                              let s:paste['+'] = ['waypaste']
                              let s:copy['*'] = ['waycopy', '-p']
                              let s:paste['*'] = ['waypaste', '-p']
                              return 'wayclip'
                            endfunction
                            
    1              0.000001 function! s:set_xsel() abort
                              let s:copy['+'] = ['xsel', '--nodetach', '-i', '-b']
                              let s:paste['+'] = ['xsel', '-o', '-b']
                              let s:copy['*'] = ['xsel', '--nodetach', '-i', '-p']
                              let s:paste['*'] = ['xsel', '-o', '-p']
                              return 'xsel'
                            endfunction
                            
    1              0.000001 function! s:set_xclip() abort
                              let s:copy['+'] = ['xclip', '-quiet', '-i', '-selection', 'clipboard']
                              let s:paste['+'] = ['xclip', '-o', '-selection', 'clipboard']
                              let s:copy['*'] = ['xclip', '-quiet', '-i', '-selection', 'primary']
                              let s:paste['*'] = ['xclip', '-o', '-selection', 'primary']
                              return 'xclip'
                            endfunction
                            
    1              0.000001 function! s:set_lemonade() abort
                              let s:copy['+'] = ['lemonade', 'copy']
                              let s:paste['+'] = ['lemonade', 'paste']
                              let s:copy['*'] = ['lemonade', 'copy']
                              let s:paste['*'] = ['lemonade', 'paste']
                              return 'lemonade'
                            endfunction
                            
    1              0.000001 function! s:set_doitclient() abort
                              let s:copy['+'] = ['doitclient', 'wclip']
                              let s:paste['+'] = ['doitclient', 'wclip', '-r']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'doitclient'
                            endfunction
                            
    1              0.000005 function! s:set_win32yank() abort
                              if has('wsl') && getftype(exepath('win32yank.exe')) == 'link'
                                let win32yank = resolve(exepath('win32yank.exe'))
                              else
                                let win32yank = 'win32yank.exe'
                              endif
                              let s:copy['+'] = [win32yank, '-i', '--crlf']
                              let s:paste['+'] = [win32yank, '-o', '--lf']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'win32yank'
                            endfunction
                            
    1              0.000001 function! s:set_putclip() abort
                              let s:copy['+'] = ['putclip']
                              let s:paste['+'] = ['getclip']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'putclip'
                            endfunction
                            
    1              0.000001 function! s:set_clip() abort
                              let s:copy['+'] = ['clip']
                              let s:paste['+'] = ['powershell', '-NoProfile', '-NoLogo', '-Command', 'Get-Clipboard']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'clip'
                            endfunction
                            
    1              0.000001 function! s:set_termux() abort
                              let s:copy['+'] = ['termux-clipboard-set']
                              let s:paste['+'] = ['termux-clipboard-get']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'termux-clipboard'
                            endfunction
                            
    1              0.000001 function! s:set_tmux() abort
                              let tmux_v = v:lua.vim.version.parse(system(['tmux', '-V']))
                              if !empty(tmux_v) && !v:lua.vim.version.lt(tmux_v, [3,2,0])
                                let s:copy['+'] = ['tmux', 'load-buffer', '-w', '-']
                              else
                                let s:copy['+'] = ['tmux', 'load-buffer', '-']
                              endif
                              let s:paste['+'] = ['sh', '-c', 'tmux refresh-client -l && sleep 0.05 && tmux save-buffer -']
                              let s:copy['*'] = s:copy['+']
                              let s:paste['*'] = s:paste['+']
                              return 'tmux'
                            endfunction
                            
    1              0.000002 let s:cache_enabled = 1
    1              0.000001 let s:err = ''
                            
    1              0.000001 function! provider#clipboard#Error() abort
                              return s:err
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Executable() abort
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
                              if exists('g:clipboard') && g:clipboard isnot# v:false
                                if v:t_string ==# type(g:clipboard)
                                  " Handle string form of g:clipboard for all builtin providers
                                  if 'osc52' == g:clipboard
                                    " User opted-in to OSC 52 by manually setting g:clipboard.
                                    return s:set_osc52()
                                  elseif 'pbcopy' == g:clipboard
                                    return s:set_pbcopy()
                                  elseif 'wl-copy' == g:clipboard
                                    return s:set_wayland()
                                  elseif 'wayclip' == g:clipboard
                                    return s:set_wayclip()
                                  elseif 'xsel' == g:clipboard
                                    return s:set_xsel()
                                  elseif 'xclip' == g:clipboard
                                    return s:set_xclip()
                                  elseif 'lemonade' == g:clipboard
                                    return s:set_lemonade()
                                  elseif 'doitclient' == g:clipboard
                                    return s:set_doitclient()
                                  elseif 'win32yank' == g:clipboard
                                    return s:set_win32yank()
                                  elseif 'putclip' == g:clipboard
                                    return s:set_putclip()
                                  elseif 'clip' == g:clipboard
                                    return s:set_clip()
                                  elseif 'termux' == g:clipboard
                                    return s:set_termux()
                                  elseif 'tmux' == g:clipboard
                                    return s:set_tmux()
                                  endif
                                endif
                            
                                if type({}) isnot# type(g:clipboard)
                                      \ || type({}) isnot# type(get(g:clipboard, 'copy', v:null))
                                      \ || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
                              elseif has('mac')
                                return s:set_pbcopy()
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                return s:set_wayland()
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                return s:set_wayclip()
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                return s:set_xsel()
                              elseif !empty($DISPLAY) && executable('xclip')
                                return s:set_xclip()
                              elseif executable('lemonade')
                                return s:set_lemonade()
                              elseif executable('doitclient')
                                return s:set_doitclient()
                              elseif executable('win32yank.exe')
                                return s:set_win32yank()
                              elseif executable('putclip') && executable('getclip')
                                return s:set_putclip()
                              elseif executable('clip') && executable('powershell')
                                return s:set_clip()
                              elseif executable('termux-clipboard-set')
                                return s:set_termux()
                              elseif !empty($TMUX) && executable('tmux')
                                return s:set_tmux()
                              elseif get(get(g:, 'termfeatures', {}), 'osc52') && &clipboard ==# ''
                                " Don't use OSC 52 when 'clipboard' is set. It can be slow and cause a lot
                                " of user prompts. Users can opt-in to it by setting g:clipboard manually.
                                return s:set_osc52()
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''
                            endfunction
                            
    1              0.000001 function! s:clipboard.get(reg) abort
                              if s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
                              end
                            
                              let clipboard_data = type(s:paste[a:reg]) == v:t_func ? s:paste[a:reg]() : s:try_cmd(s:paste[a:reg])
                              if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0
                                    \ && type(clipboard_data) == v:t_list
                                    \ && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
                                return s:selections[a:reg].data
                              end
                              return clipboard_data
                            endfunction
                            
    1              0.000001 function! s:clipboard.set(lines, regtype, reg) abort
                              if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
                            
                              if s:cache_enabled == 0 || type(s:copy[a:reg]) == v:t_func
                                if type(s:copy[a:reg]) == v:t_func
                                  call s:copy[a:reg](a:lines, a:regtype)
                                else
                                  call s:try_cmd(s:copy[a:reg], a:lines)
                                endif
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let selection.argv = s:copy[a:reg]
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(selection.argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
                                if selection.argv[0] ==# 'xclip'
                                  call jobclose(jobid, 'stdout')
                                endif
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... ->
                                      \ jobwait([prev_job], 0)[0] == -1
                                      \ && jobstop(prev_job)})
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000001 function! provider#clipboard#Call(method, args) abort
                              if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
                              endif
                              let s:here = v:true
                              try
                                return call(s:clipboard[a:method],a:args,s:clipboard)
                              finally
                                let s:here = v:false
                              endtry
                            endfunction
                            
                            " eval_has_provider() decides based on this variable.
    1   0.000108   0.000032 let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 0 : 2

SCRIPT  /Users/albertos/.local/share/nvim/sessions/%2FUsers%2Falbertos%2F%2Econfig.vim
Sourced 1 time
Total time:   0.297563
 Self time:   0.020725

count  total (s)   self (s)
    1              0.000020 let SessionLoad = 1
    1   0.000045   0.000029 let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
    1              0.000042 let v:this_session=expand("<sfile>:p")
    1              0.000049 silent only
    1              0.000269 cd ~/.config
    1              0.000016 if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
    1              0.000005   let s:wipebuf = bufnr('%')
    1              0.000001 endif
    1              0.000002 let s:shortmess_save = &shortmess
    1   0.000009   0.000006 set shortmess+=aoO
    1   0.000875   0.000831 badd +1 ~/.config/nvim/lua/config/plugins/snacks.lua
    1   0.000110   0.000092 badd +1 ~/.local/state/nvim/mini-deps.log
    1   0.000109   0.000094 badd +1 ~/.config/nvim/newinit.lua
    1   0.000748   0.000726 badd +8 nvim/init.lua
    1   0.000403   0.000376 badd +1 ~/.config/nvim/lua/config/plugins/mason-lspconfig.lua
    1   0.000442   0.000391 badd +6 ~/.config/nvim/lua/config/plugins/lsp.lua
    1   0.000744   0.000687 badd +34 ~/.config/nvim/lua/config/plugins/gitsigns.lua
    1   0.001081   0.001053 badd +4 ~/.config/lazygit/config.yml
    1   0.000572   0.000551 badd +14 ~/.config/git/config
    1   0.000366   0.000346 badd +98 ~/.config/nvim/lua/config/plugins/conform.lua
    1   0.000147   0.000131 badd +7 Grug\ FAR\ -\ 1:\ leader>rn
    1   0.000588   0.000492 badd +3 nvim/lua/config/plugins/vimade.lua
    1   0.000825   0.000634 badd +8 ~/.local/share/nvim/lazy/plugins/vimade/lua/vimade/init.lua
    1   0.000660   0.000599 badd +1 ~/.local/share/nvim/lazy/plugins/vimade/lua/vimade/config_helpers/blocklist.lua
    1   0.000233   0.000187 badd +7 Grug\ FAR\ -\ 2:\ function\ toggle/(
    1   0.000550   0.000468 badd +21 nvim/lua/config/plugins/pairs.lua
    1   0.000237   0.000165 badd +1 ~/.config/nvim/lua/config/plugins/satellite.lua
    1   0.000527   0.000461 badd +12 ~/.config/nvim/lua/config/plugins/color-picker.lua
    1   0.000477   0.000435 badd +12 ~/.config/nvim/lua/config/plugins/illuminate.lua
    1   0.000599   0.000578 badd +61 ~/.config/fish/config.fish
    1   0.000159   0.000129 badd +1 Grug\ FAR\ -\ 3:\ LDFLAGS
    1   0.000449   0.000425 badd +32 ~/.config/nvim/lua/config/plugins/blink.lua
    1   0.000433   0.000413 badd +19 nvim/lua/config/plugins/scrollbar.lua
    1   0.000163   0.000149 badd +1 nvim/lua/config/plugins/scrollview.lua
    1   0.000514   0.000482 badd +1 ~/.config/nvim/lua/config/plugins/catppuccin.lua
    1   0.000207   0.000184 badd +4 Grug\ FAR\ -\ 4:\ diagnostic
    1   0.000577   0.000546 badd +24 nvim/lua/config/plugins/hllens.lua
    1   0.000463   0.000434 badd +6 ~/.config/nvim/lua/config/plugins/leap.lua
    1   0.000193   0.000170 badd +52 Grug\ FAR\ -\ 5:\ leader.\*r
    1   0.000726   0.000700 badd +153 ~/.local/share/nvim/lazy/plugins/nvim-scrollbar/lua/scrollbar/config.lua
    1   0.000416   0.000382 badd +277 ~/.local/share/nvim/lazy/plugins/nvim-scrollbar/lua/scrollbar/init.lua
    1   0.000511   0.000485 badd +11 ~/.config/nvim/lua/config/plugins/modes.lua
    1   0.000400   0.000380 badd +27 ~/.config/starship.toml
    1   0.000399   0.000337 badd +26 ~/.config/nvim/lua/config/plugins/treesitter.lua
    1   0.000675   0.000606 badd +96 ~/.config/nvim/lua/config/winbar.lua
    1   0.000634   0.000611 badd +137 ~/.config/tmux/tmux.conf
    1   0.000569   0.000548 badd +119 ~/.config/ghostty/config
    1   0.000331   0.000311 badd +1 ~/.config/nvim/lua/config/colors.lua
    1              0.000003 argglobal
    1              0.000002 %argdel
    1   0.278409   0.003159 edit ~/.config/nvim/lua/config/plugins/catppuccin.lua
    1              0.000004 argglobal
    1              0.000338 balt ~/.config/nvim/lua/config/plugins/snacks.lua
    1              0.000012 let s:l = 1 - ((0 * winheight(0) + 23) / 46)
    1              0.000003 if s:l < 1 | let s:l = 1 | endif
    1              0.000008 keepjumps exe s:l
    1              0.000024 normal! zt
    1              0.000001 keepjumps 1
    1              0.000005 normal! 0
    1              0.000009 if exists('s:wipebuf') && len(win_findbuf(s:wipebuf)) == 0 && getbufvar(s:wipebuf, '&buftype') isnot# 'terminal'
    1   0.000064   0.000041   silent exe 'bwipe ' . s:wipebuf
    1              0.000001 endif
    1              0.000002 unlet! s:wipebuf
    1   0.000009   0.000006 set winheight=1 winwidth=20
    1   0.000006   0.000004 let &shortmess = s:shortmess_save
    1              0.000012 let s:sx = expand("<sfile>:p:r")."x.vim"
    1              0.000017 if filereadable(s:sx)
                              exe "source " . fnameescape(s:sx)
    1              0.000000 endif
    1   0.000009   0.000005 let &g:so = s:so_save | let &g:siso = s:siso_save
    1   0.000003   0.000002 set hlsearch
    1              0.000000 nohlsearch
    1   0.000013   0.000003 doautoall SessionLoadPost
    1              0.000001 unlet SessionLoad
                            " vim: set ft=vim :

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-treesitter/plugin/filetypes.lua
Sourced 1 time
Total time:   0.006163
 Self time:   0.006163

count  total (s)   self (s)
                            local filetypes = {
                              angular = { 'htmlangular' },
                              bash = { 'sh' },
                              bibtex = { 'bib' },
                              c_sharp = { 'cs', 'csharp', 'c-sharp' },
                              commonlisp = { 'lisp' },
                              cooklang = { 'cook' },
                              devicetree = { 'dts' },
                              diff = { 'gitdiff' },
                              eex = { 'eelixir' },
                              elixir = { 'ex' },
                              embedded_template = { 'eruby' },
                              erlang = { 'erl' },
                              facility = { 'fsd' },
                              faust = { 'dsp' },
                              gdshader = { 'gdshaderinc' },
                              git_config = { 'gitconfig' },
                              git_rebase = { 'gitrebase' },
                              glimmer = { 'handlebars', 'html.handlebars' },
                              godot_resource = { 'gdresource' },
                              haskell = { 'hs' },
                              haskell_persistent = { 'haskellpersistent' },
                              idris = { 'idris2' },
                              ini = { 'confini', 'dosini' },
                              janet_simple = { 'janet' },
                              javascript = { 'javascriptreact', 'ecma', 'ecmascript', 'jsx', 'js' },
                              json = { 'jsonc' },
                              glimmer_javascript = { 'javascript.glimmer' },
                              latex = { 'tex' },
                              linkerscript = { 'ld' },
                              m68k = { 'asm68k' },
                              make = { 'automake' },
                              markdown = { 'pandoc' },
                              muttrc = { 'neomuttrc' },
                              ocaml_interface = { 'ocamlinterface' },
                              perl = { 'pl' },
                              poe_filter = { 'poefilter' },
                              powershell = { 'ps1' },
                              properties = { 'jproperties' },
                              python = { 'py', 'gyp' },
                              qmljs = { 'qml' },
                              runescript = { 'clientscript' },
                              scala = { 'sbt' },
                              slang = { 'shaderslang' },
                              sqp = { 'mysqp' },
                              ssh_config = { 'sshconfig' },
                              starlark = { 'bzl' },
                              surface = { 'sface' },
                              systemverilog = { 'verilog' },
                              t32 = { 'trace32' },
                              tcl = { 'expect' },
                              terraform = { 'terraform-vars' },
                              textproto = { 'pbtxt' },
                              tlaplus = { 'tla' },
                              tsx = { 'typescriptreact', 'typescript.tsx' },
                              typescript = { 'ts' },
                              glimmer_typescript = { 'typescript.glimmer' },
                              typst = { 'typ' },
                              udev = { 'udevrules' },
                              uxntal = { 'tal', 'uxn' },
                              v = { 'vlang' },
                              vhs = { 'tape' },
                              xml = { 'xsd', 'xslt', 'svg' },
                              xresources = { 'xdefaults' },
                            }
                            
                            for lang, ft in pairs(filetypes) do
                              vim.treesitter.language.register(lang, ft)
                            end

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-treesitter/plugin/nvim-treesitter.lua
Sourced 1 time
Total time:   0.004571
 Self time:   0.004571

count  total (s)   self (s)
                            if vim.g.loaded_nvim_treesitter then
                              return
                            end
                            vim.g.loaded_nvim_treesitter = true
                            
                            local api = vim.api
                            
                            local function complete_available_parsers(arglead)
                              return vim.tbl_filter(
                                --- @param v string
                                function(v)
                                  return v:find(arglead) ~= nil
                                end,
                                require('nvim-treesitter.config').get_available()
                              )
                            end
                            
                            local function complete_installed_parsers(arglead)
                              return vim.tbl_filter(
                                --- @param v string
                                function(v)
                                  return v:find(arglead) ~= nil
                                end,
                                require('nvim-treesitter.config').get_installed()
                              )
                            end
                            
                            -- create user commands
                            api.nvim_create_user_command('TSInstall', function(args)
                              require('nvim-treesitter.install').install(args.fargs, { force = args.bang, summary = true })
                            end, {
                              nargs = '+',
                              bang = true,
                              bar = true,
                              complete = complete_available_parsers,
                              desc = 'Install treesitter parsers',
                            })
                            
                            api.nvim_create_user_command('TSInstallFromGrammar', function(args)
                              require('nvim-treesitter.install').install(args.fargs, {
                                generate = true,
                                summary = true,
                                force = args.bang,
                              })
                            end, {
                              nargs = '+',
                              bang = true,
                              bar = true,
                              complete = complete_available_parsers,
                              desc = 'Install treesitter parsers from grammar',
                            })
                            
                            api.nvim_create_user_command('TSUpdate', function(args)
                              require('nvim-treesitter.install').update(args.fargs, { summary = true })
                            end, {
                              nargs = '*',
                              bar = true,
                              complete = complete_installed_parsers,
                              desc = 'Update installed treesitter parsers',
                            })
                            
                            api.nvim_create_user_command('TSUninstall', function(args)
                              require('nvim-treesitter.install').uninstall(args.fargs, { summary = true })
                            end, {
                              nargs = '+',
                              bar = true,
                              complete = complete_installed_parsers,
                              desc = 'Uninstall treesitter parsers',
                            })
                            
                            api.nvim_create_user_command('TSLog', function()
                              require('nvim-treesitter.log').show()
                            end, {
                              desc = 'View log messages',
                            })

SCRIPT  /Users/albertos/.local/share/nvim/lazy/plugins/nvim-treesitter/plugin/query_predicates.lua
Sourced 1 time
Total time:   0.004610
 Self time:   0.004610

count  total (s)   self (s)
                            local query = vim.treesitter.query
                            
                            local predicates = {
                              ---@param match table<integer,TSNode[]>
                              ---@param pred any[]
                              ---@param any boolean
                              ---@return boolean
                              ['kind-eq'] = function(match, pred, any)
                                local nodes = match[pred[2]]
                                if not nodes or #nodes == 0 then
                                  return true
                                end
                            
                                local types = { unpack(pred, 3) }
                                for _, node in ipairs(nodes) do
                                  local res = vim.list_contains(types, node:type())
                                  if any and res then
                                    return true
                                  elseif not any and not res then
                                    return false
                                  end
                                end
                                return not any
                              end,
                            }
                            
                            -- register custom predicates (overwrite existing; needed for CI)
                            
                            ---@param match table<integer,TSNode[]>
                            ---@param pred any[]
                            ---@return boolean
                            query.add_predicate('kind-eq?', function(match, _, _, pred)
                              return predicates['kind-eq'](match, pred, false)
                            end, { force = true })
                            
                            ---@param match table<integer,TSNode[]>
                            ---@param pred any[]
                            ---@return boolean
                            query.add_predicate('any-kind-eq?', function(match, _, _, pred)
                              return predicates['kind-eq'](match, pred, true)
                            end, { force = true })

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/ftplugin/lua.vim
Sourced 2 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Tyler Miller <tmillr@proton.me>
                            "			Phạm Bình An <phambinhanctb2004@gmail.com>
                            "			@konfekt
                            " Last Change:		2025 Apr 04
                            " 2025 May 06 by Vim Project update 'path' setting #17267
                            
    2              0.000012 if exists("b:did_ftplugin")
                              finish
    2              0.000001 endif
    2              0.000005 let b:did_ftplugin = 1
                            
                            " keep in sync with syntax/lua.vim
    2              0.000004 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000002   let lua_version = 5
    1              0.000002   let lua_subversion = 3
    1              0.000002 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    2              0.000001 endif
                            
    2              0.000005 let s:cpo_save = &cpo
    2              0.000015 set cpo&vim
                            
    2              0.000012 setlocal comments=:---,:--
    2              0.000009 setlocal commentstring=--\ %s
    2              0.000011 setlocal formatoptions-=t formatoptions+=croql
    2              0.000008 setlocal path-=. " Lua doesn't support importing module in path related to current file like JS
                            
    2              0.000012 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    2              0.000010 let &l:include = '\<\%(\%(do\|load\)file\|require\)\s*('
    2              0.000009 setlocal includeexpr=s:LuaInclude(v:fname)
    2              0.000008 setlocal suffixesadd=.lua
                            
    2              0.000004 let b:undo_ftplugin = "setl cms< com< def< fo< inc< inex< sua< pa<"
                            
    2              0.000006 if exists("loaded_matchit") && !exists("b:match_words")
                              let b:match_ignorecase = 0
                              let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
                              let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    2              0.000001 endif
                            
    2              0.000020 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    2              0.000001 endif
                            
                            " The rest of the file needs to be :sourced only once per Vim session
    2              0.000006 if exists("s:loaded_lua") || &cp
    1              0.000003   let &cpo = s:cpo_save
    1              0.000001   unlet s:cpo_save
    1              0.000002   finish
    1              0.000001 endif
    1              0.000001 let s:loaded_lua = 1
                            
    1              0.000005 function s:LuaInclude(fname) abort
                              let lua_ver = str2float(printf("%d.%02d", g:lua_version, g:lua_subversion))
                              let fname = tr(a:fname, '.', '/')
                              let paths = lua_ver >= 5.03 ? [fname .. ".lua", fname .. "/init.lua"] : [fname .. ".lua"]
                              for path in paths
                                if filereadable(path)
                                  return path
                                endif
                              endfor
                              return fname
                            endfunction
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/ftplugin/lua.lua
Sourced 2 times
Total time:   0.067574
 Self time:   0.067308

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()
                            
                            vim.bo.includeexpr = [[v:lua.require'vim._ftplugin.lua'.includeexpr(v:fname)]]
                            vim.bo.omnifunc = 'v:lua.vim.lua_omnifunc'
                            vim.wo[0][0].foldexpr = 'v:lua.vim.treesitter.foldexpr()'
                            
                            vim.b.undo_ftplugin = (vim.b.undo_ftplugin or '')
                              .. '\n call v:lua.vim.treesitter.stop()'
                              .. '\n setl omnifunc< foldexpr< includeexpr<'

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/indent/lua.vim
Sourced 2 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            "		2024 Jul 27: by Vim project: match '(', ')' in function GetLuaIndentIntern()
                            
                            " Only load this indent file when no other was loaded.
    2              0.000008 if exists("b:did_indent")
                              finish
    2              0.000002 endif
    2              0.000004 let b:did_indent = 1
                            
    2              0.000013 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    2              0.000008 setlocal indentkeys+=0=end,0=until
                            
    2              0.000006 setlocal autoindent
                            
    2              0.000004 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    2              0.000007 if exists("*GetLuaIndent")
    1              0.000001   finish
    1              0.000001 endif
                            
    1              0.000004 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000002 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

SCRIPT  /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.000906
 Self time:   0.000906

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2025 Feb 25
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    1              0.000011 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            " keep in sync with ftplugin/lua.vim
    1              0.000002 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    1              0.000002 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000000 endif
                            
    1              0.000002 syn case match
                            
                            " syncing method
    1              0.000004 syn sync minlines=1000
                            
    1              0.000002 if lua_version >= 5
    1              0.000008   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    1              0.000002   syn keyword luaMetaMethod __eq __lt __le
    1              0.000002   syn keyword luaMetaMethod __index __newindex __call
    1              0.000003   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    1              0.000000 endif
                            
    1              0.000002 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    1              0.000001   syn keyword luaMetaMethod __mod __len
    1              0.000000 endif
                            
    1              0.000002 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaMetaMethod __pairs
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    1              0.000001   syn keyword luaMetaMethod __idiv __name
    1              0.000001   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    1              0.000000 endif
                            
    1              0.000001 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    1              0.000000 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    1              0.000044 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    1              0.000002 syn match  luaParenError ")"
    1              0.000004 syn match  luaError "}"
    1              0.000006 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    1              0.000008 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    1              0.000003 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    1              0.000006 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    1              0.000007 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    1              0.000005 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    1              0.000004 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    1              0.000005 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    1              0.000004 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000005 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000002 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    1              0.000001 syn keyword luaStatement return local break
    1              0.000002 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaStatement goto
    1              0.000003   syn match luaLabel "::\I\i*::"
    1              0.000000 endif
                            
                            " operators
    1              0.000002 syn keyword luaOperator and or not
                            
    1              0.000002 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    1              0.000006   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    1              0.000000 endif
                            
                            " comments
    1              0.000002 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000005 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000021 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000002 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000006   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000000 endif
                            
                            " first line may start with #!
    1              0.000002 syn match luaComment "\%^#!.*"
                            
    1              0.000001 syn keyword luaConstant nil
    1              0.000001 if lua_version > 4
    1              0.000002   syn keyword luaConstant true false
    1              0.000000 endif
                            
                            " strings
    1              0.000008 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    1              0.000001 if lua_version == 5
    1              0.000001   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000001   else
    1              0.000001     if lua_subversion >= 2
    1              0.000003       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 3
    1              0.000004       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    1              0.000000     endif
    1              0.000004     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000000   endif
    1              0.000000 endif
    1              0.000006 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000004 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000003 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000004 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    1              0.000003 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000002 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000001 if lua_version >= 5
    1              0.000001   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000001   elseif lua_subversion >= 2
    1              0.000003     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000000   endif
    1              0.000000 endif
                            
                            " tables
    1              0.000007 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    1              0.000005 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    1              0.000002 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000002 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    1              0.000001 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000001 elseif lua_version == 5
    1              0.000001   syn keyword luaFunc getmetatable setmetatable
    1              0.000001   syn keyword luaFunc ipairs pairs
    1              0.000001   syn keyword luaFunc pcall xpcall
    1              0.000001   syn keyword luaFunc _G loadfile rawequal require
    1              0.000001   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000000   else
    1              0.000001     syn keyword luaFunc load select
    1              0.000002     syn match   luaFunc /\<package\.cpath\>/
    1              0.000002     syn match   luaFunc /\<package\.loaded\>/
    1              0.000002     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000003     syn match   luaFunc /\<package\.path\>/
    1              0.000002     syn match   luaFunc /\<package\.preload\>/
    1              0.000001     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000002     elseif lua_subversion >= 2
    1              0.000001       syn keyword luaFunc _ENV rawlen
    1              0.000002       syn match   luaFunc /\<package\.config\>/
    1              0.000002       syn match   luaFunc /\<package\.preload\>/
    1              0.000002       syn match   luaFunc /\<package\.searchers\>/
    1              0.000002       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000000     endif
                            
    1              0.000001     if lua_subversion >= 3
    1              0.000003       syn match luaFunc /\<coroutine\.isyieldable\>/
    1              0.000000     endif
    1              0.000001     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    1              0.000000     endif
    1              0.000002     syn match luaFunc /\<coroutine\.running\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000002   syn match   luaFunc /\<coroutine\.yield\>/
                            
    1              0.000002   syn match   luaFunc /\<string\.byte\>/
    1              0.000002   syn match   luaFunc /\<string\.char\>/
    1              0.000029   syn match   luaFunc /\<string\.dump\>/
    1              0.000002   syn match   luaFunc /\<string\.find\>/
    1              0.000002   syn match   luaFunc /\<string\.format\>/
    1              0.000008   syn match   luaFunc /\<string\.gsub\>/
    1              0.000002   syn match   luaFunc /\<string\.len\>/
    1              0.000002   syn match   luaFunc /\<string\.lower\>/
    1              0.000002   syn match   luaFunc /\<string\.rep\>/
    1              0.000002   syn match   luaFunc /\<string\.sub\>/
    1              0.000002   syn match   luaFunc /\<string\.upper\>/
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000000   else
    1              0.000002     syn match luaFunc /\<string\.gmatch\>/
    1              0.000002     syn match luaFunc /\<string\.match\>/
    1              0.000002     syn match luaFunc /\<string\.reverse\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 3
    1              0.000002     syn match luaFunc /\<string\.pack\>/
    1              0.000002     syn match luaFunc /\<string\.packsize\>/
    1              0.000002     syn match luaFunc /\<string\.unpack\>/
    1              0.000002     syn match luaFunc /\<utf8\.char\>/
    1              0.000002     syn match luaFunc /\<utf8\.charpattern\>/
    1              0.000002     syn match luaFunc /\<utf8\.codes\>/
    1              0.000002     syn match luaFunc /\<utf8\.codepoint\>/
    1              0.000010     syn match luaFunc /\<utf8\.len\>/
    1              0.000002     syn match luaFunc /\<utf8\.offset\>/
    1              0.000000   endif
                            
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000001   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000001   elseif lua_subversion >= 2
    1              0.000002     syn match luaFunc /\<table\.pack\>/
    1              0.000002     syn match luaFunc /\<table\.unpack\>/
    1              0.000001     if lua_subversion >= 3
    1              0.000002       syn match luaFunc /\<table\.move\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<table\.concat\>/
    1              0.000002   syn match   luaFunc /\<table\.insert\>/
    1              0.000002   syn match   luaFunc /\<table\.sort\>/
    1              0.000002   syn match   luaFunc /\<table\.remove\>/
                            
    1              0.000001   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000000   endif
                            
    1              0.000002   syn match   luaFunc /\<math\.abs\>/
    1              0.000002   syn match   luaFunc /\<math\.acos\>/
    1              0.000002   syn match   luaFunc /\<math\.asin\>/
    1              0.000001   syn match   luaFunc /\<math\.atan\>/
    1              0.000001   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    1              0.000000   endif
    1              0.000013   syn match   luaFunc /\<math\.ceil\>/
    1              0.000002   syn match   luaFunc /\<math\.sin\>/
    1              0.000001   syn match   luaFunc /\<math\.cos\>/
    1              0.000001   syn match   luaFunc /\<math\.tan\>/
    1              0.000001   syn match   luaFunc /\<math\.deg\>/
    1              0.000001   syn match   luaFunc /\<math\.exp\>/
    1              0.000002   syn match   luaFunc /\<math\.floor\>/
    1              0.000001   syn match   luaFunc /\<math\.log\>/
    1              0.000001   syn match   luaFunc /\<math\.max\>/
    1              0.000001   syn match   luaFunc /\<math\.min\>/
    1              0.000001   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000001   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000002     syn match luaFunc /\<math\.huge\>/
    1              0.000001     syn match luaFunc /\<math\.fmod\>/
    1              0.000001     syn match luaFunc /\<math\.modf\>/
    1              0.000001     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.rad\>/
    1              0.000001   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000001   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    1              0.000000   else
    1              0.000002     syn match   luaFunc /\<math\.maxinteger\>/
    1              0.000011     syn match   luaFunc /\<math\.mininteger\>/
    1              0.000002     syn match   luaFunc /\<math\.tointeger\>/
    1              0.000002     syn match   luaFunc /\<math\.type\>/
    1              0.000001     syn match   luaFunc /\<math\.ult\>/
    1              0.000000   endif
    1              0.000002   syn match   luaFunc /\<math\.random\>/
    1              0.000002   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000001   syn match   luaFunc /\<math\.pi\>/
                            
    1              0.000001   syn match   luaFunc /\<io\.close\>/
    1              0.000001   syn match   luaFunc /\<io\.flush\>/
    1              0.000001   syn match   luaFunc /\<io\.input\>/
    1              0.000007   syn match   luaFunc /\<io\.lines\>/
    1              0.000001   syn match   luaFunc /\<io\.open\>/
    1              0.000001   syn match   luaFunc /\<io\.output\>/
    1              0.000001   syn match   luaFunc /\<io\.popen\>/
    1              0.000001   syn match   luaFunc /\<io\.read\>/
    1              0.000001   syn match   luaFunc /\<io\.stderr\>/
    1              0.000001   syn match   luaFunc /\<io\.stdin\>/
    1              0.000001   syn match   luaFunc /\<io\.stdout\>/
    1              0.000001   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000001   syn match   luaFunc /\<io\.type\>/
    1              0.000001   syn match   luaFunc /\<io\.write\>/
                            
    1              0.000001   syn match   luaFunc /\<os\.clock\>/
    1              0.000001   syn match   luaFunc /\<os\.date\>/
    1              0.000002   syn match   luaFunc /\<os\.difftime\>/
    1              0.000005   syn match   luaFunc /\<os\.execute\>/
    1              0.000001   syn match   luaFunc /\<os\.exit\>/
    1              0.000001   syn match   luaFunc /\<os\.getenv\>/
    1              0.000001   syn match   luaFunc /\<os\.remove\>/
    1              0.000001   syn match   luaFunc /\<os\.rename\>/
    1              0.000002   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000001   syn match   luaFunc /\<os\.time\>/
    1              0.000001   syn match   luaFunc /\<os\.tmpname\>/
                            
    1              0.000005   syn match   luaFunc /\<debug\.debug\>/
    1              0.000002   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000002   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000002   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000002   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000002   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000002   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000002   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000002   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000001   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    1              0.000000   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000003     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000002     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000002     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000001     if lua_subversion >= 2
    1              0.000002       syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000002       syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000002       syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000008       syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000001     endif
    1              0.000001     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    1              0.000000     endif
    1              0.000000   endif
    1              0.000000 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000004 hi def link luaStatement        Statement
    1              0.000001 hi def link luaRepeat           Repeat
    1              0.000001 hi def link luaFor              Repeat
    1              0.000001 hi def link luaString           String
    1              0.000001 hi def link luaString2          String
    1              0.000001 hi def link luaStringDelimiter  luaString
    1              0.000001 hi def link luaNumber           Number
    1              0.000002 hi def link luaOperator         Operator
    1              0.000001 hi def link luaSymbolOperator   luaOperator
    1              0.000001 hi def link luaConstant         Constant
    1              0.000001 hi def link luaCond             Conditional
    1              0.000001 hi def link luaCondElse         Conditional
    1              0.000001 hi def link luaFunction         Function
    1              0.000001 hi def link luaMetaMethod       Function
    1              0.000002 hi def link luaComment          Comment
    1              0.000001 hi def link luaCommentDelimiter luaComment
    1              0.000001 hi def link luaTodo             Todo
    1              0.000001 hi def link luaTable            Structure
    1              0.000001 hi def link luaError            Error
    1              0.000001 hi def link luaParenError       Error
    1              0.000001 hi def link luaSpecial          SpecialChar
    1              0.000002 hi def link luaFunc             Identifier
    1              0.000001 hi def link luaLabel            Label
                            
                            
    1              0.000003 let b:current_syntax = "lua"
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            " vim: et ts=8 sw=2

FUNCTION  <SNR>9_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/matchparen.vim:45
Called 104 times
Total time:   0.005456
 Self time:   0.004653

count  total (s)   self (s)
  104              0.000455   if !exists("w:matchparen_ids")
    1              0.000005     let w:matchparen_ids = []
  104              0.000067   endif
                              " Remove any previous match.
  104   0.001418   0.000615   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  104              0.000276   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  104              0.000023   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  104              0.000173   let c_lnum = line('.')
  104              0.000133   let c_col = col('.')
  104              0.000053   let before = 0
                            
  104              0.000159   let text = getline(c_lnum)
  104              0.000283   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  104              0.000172   let c = text->strpart(c_col - 1)->slice(0, 1)
  104              0.000946   let plist = split(&matchpairs, '.\zs[:,]')
  104              0.000166   let i = index(plist, c)
  104              0.000050   if i < 0
                                " not found, in Insert mode try character before the cursor
  104              0.000121     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  104              0.000025     endif
  104              0.000039     if i < 0
                                  " not found, nothing to do
  104              0.000051       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
                                if !g:matchparen_disable_cursor_hl
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  vimade#Disable()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:402
Called 2 times
Total time:   0.000166
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000021   if winnr() == 0
                                return
    2              0.000003   endif
                              "disable vimade
    2              0.000008   let g:vimade_running = 0
    2   0.000033   0.000011   call vimade#StopTimer()
    2   0.000092   0.000009   call g:vimade_active_renderer.disable()

FUNCTION  vimade#CreateGlobals()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:9
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                              "let g:vimade_lua_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'lua'
                              "let g:vimade_py_v2_renderer = exists('g:vimade') && get(g:vimade, 'renderer') =~ 'python-v2'
                            
    1              0.000003   if !exists('g:vimade_running')
                                ""@setting vimade_running
                                "This flag is used to control whether or not vimade should be running.  This can be useful to toggle vimade during startup.  Alternatively, you may as also use VimadeDisable, VimadeEnable, call vimade#Disable, call vimade#Enable respectively
                            
    1              0.000002     let g:vimade_running = 1
    1              0.000001   endif
    1              0.000002   let g:vimade_paused = 0
    1              0.000002   let g:vimade_error_count = 0
    1              0.000004   let g:vimade_fade_active = 0
    1              0.000002   if !exists('g:vimade')
                                let g:vimade = {}
    1              0.000001   endif
    1              0.000002   if !exists('g:vimade_overlay')
    1              0.000009     let g:vimade_overlay = {}
    1              0.000001   endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/ftplugin.vim:15
Called 78 times
Total time:   0.240040
 Self time:   0.158544

count  total (s)   self (s)
   78              0.000492     if exists("b:undo_ftplugin")
    1   0.013729   0.000157       exe b:undo_ftplugin
    1              0.000003       unlet! b:undo_ftplugin b:did_ftplugin
   78              0.000063     endif
                            
   78              0.000395     let s = expand("<amatch>")
   78              0.000098     if s != ""
   78              0.000449       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   78              0.000024       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
  156              0.000512       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   78   0.222899   0.154974         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
  156              0.000298       endfor
   78              0.000039     endif

FUNCTION  vimade#DeferredTick()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:578
Called 1 time
Total time:   0.000334
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000018   unlet g:vimade_deferred_timer
    1   0.000314   0.000016   call vimade#Tick(0)

FUNCTION  vimade#GetDefaults()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:139
Called 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000003   if !exists('g:vimade_defaults')
                            
                                ""The vimade configuration object
                                "@setting vimade
                                
    1              0.000003     let g:vimade_defaults = {'$extended': 1}
                            
                                ""@setting vimade.renderer
                                "Select the renderer to use for vimade window/buffer highlights.
                                "If not specificed, defaults to 'auto'. It is recommended to leave this
                                "option set to 'auto', 'lua', or 'python'.
                                "Current options are:
                                "  - 'auto' - Uses lua renderer if supported on your Neovim version. Otherwise, this option will automatically fallback to 'python'.
                                "  - 'python' - Uses a new high performance renderer compatible with Vim and Neovim
                            
    1              0.000002     let g:vimade_defaults.renderer = 'auto'
                            
                                ""@setting vimade.fadelevel
                                "Supported:     lua, python
                                "Amount of fading applied between text and basebg.  0 will make the text the same color as the background and 1 applies no fading.  The default value is 0.4.  If you are using terminal, you may need to tweak this value to get better results.
                            
    1              0.000005     let g:vimade_defaults.fadelevel = 0.4
                                
                                ""@setting vimade.tint
                                "Supported:     lua, python
                                "Amount and type of tinting to apply. Unset by default.  This param is currently under maintainence. This function can currently be either a config object such as:
                                "{'fg':{'rgb':[255,0,0], 'intensity': 0.5, 'type': 'MIX'}, 'bg':{'rgb':[255,0,0], 'type': 'REPLACE'}, 'sp': {'rgb':[255,0,0], 'type': 'MIX'}}
                                "The fields in the object are completely optional (you can peform a bg-only or fg-only tint)
                                "You can also set g:vimade.tint to a lua or python function that returns the tint object.
                                "Lua
                                "require('vimade').setup({
                                " tint = function (win)
                                "   return {
                                "    fg = {
                                "      rgb={255,0,0},
                                "      intensity = 0.75,
                                "    },
                                "  }
                                " end
                                "})
                                "Python
                                "from vimade.v2 import vimade
                                "vimade.setup({
                                " 'tint': lambda a,test : {'fg':{'rgb':[255,0,0], 'intensity': 0.5}}
                                "})
                            
                                ""@setting vimade.basebg
                                "Supported:     lua, python
                                "basebg can be either be six digit hexidecimal color, rgb array [0-255,0-255,0-255], or cterm code (in terminal).  basebg is used as the color that text is faded against.  You can override this config with another hexidecimal color.  A cool feature of basebg is to use it to change the tint of faded text even if its not your background!
                            
    1              0.000002     let g:vimade_defaults.basebg = ''
                                "
                                ""@setting vimade.recipe
                                "Supported:     ['default', {}], ['minimalist', {}], ['duo', {'animate': v:false}]
                                " The second argument in the array overrides the recipe settings (e.g.
                                " {'animate': v:true})
                                " May also specify recipe as just 'default' or ['default']
                            
                                " unset - but automatically picked up if user changes and has not set via
                                " overlay
    1              0.000002     let g:vimade_defaults.recipe = 'default'
    1              0.000002     let g:vimade.__recipe = 'default' 
    1              0.000002     let g:__vimade_recipe_applied = 0 
                            
                                ""@setting vimade.ncmode
                                "Supported:     lua, python
                                "Whether to fade active windows or buffers.  Options are 'windows' or 'buffers'.  Defaults to 'buffers'.
                            
    1              0.000002     let g:vimade_defaults.ncmode = 'buffers'
                            
                                "Can be set via vim object
                                ""@setting vimade.blocklist
                                "Supported:     lua, python
                                "TODO docs
                            
                                ""@setting vimade.link
                                "Supported:     lua, python
                                "Controls whether or not diffs will fade/unfade together.
                                "TODO docs
                            
                            
                                ""@setting vimade.groupdiff
                                "Supported:     lua, python
                                "Controls whether or not diffs will fade/unfade together.  If you want diffs
                                "to be treated separately, set this value to 0. Default is 1
                            
    1              0.000002     let g:vimade_defaults.groupdiff = 1
                            
                                ""@setting vimade.groupscrollbind
                                "Supported:     lua, python
                                "Controls whether or not scrollbound windows will fade/unfade together.  If
                                "you want scrollbound windows to unfade together, set this to 1.  Default is
                                "0.
                                
    1              0.000002     let g:vimade_defaults.groupscrollbind = 0
                            
                                ""@setting vimade.enablefocusfading
                                "Supported:     lua, python
                                "Fades the current active window on focus blur and unfades when focus gained.
                                "This can be desirable when switching applications or TMUX splits.
                                "* Install 'tmux-plugins/vim-tmux-focus-events' using your preferred plugin manager
                                "* Add `set -g focus-events on` to your tmux.conf
                                "* Neovim should work at this point, If you are using Vim you may also need the following snippet to the very end of your vimrc
                                ">
                                "  if has('gui_running') == 0 && has('nvim') == 0
                                "     call feedkeys(":silent execute '!' | redraw!\<CR>")
                                "  endif
                                "<
                            
    1              0.000002     let g:vimade_defaults.enablefocusfading = 0
                               
                                ""@setting vimade.normalid
                                "Supported:     lua, python
                                "If not specified, the normalid is determined when vimade is first loaded.  normalid provides the id of the "Normal" highlight which is used to calculate fading.  You can override this config with another highlight group.
                                "You shouldn't really ever need to modify this.
                            
    1              0.000002     let g:vimade_defaults.normalid = ''
                            
                                ""@setting vimade.normalncid
                                "Supported:     lua, python
                                "If not specified, the normalncid is determined when vimade is first loaded.  normalncid provides the id of the "NormalNC" highlight which is used to calculate fading for inactive buffers in NVIM.  You can override this config with another highlight group.
                                "You shouldn't really ever need to modify this.
                            
    1              0.000002     let g:vimade_defaults.normalncid = ''
                            
                                ""@setting vimade.checkinterval
                                "Supported:     lua, python
                                "The amount of time in milliseconds that vimade should check the screen for changes.  This config is mainly used to detect resize and scroll changes that occur on inactive windows. Checkinterval does nothing on gvim, if you want to control the refresh time, see 'h updatetime'. Default is 1000.  
                            
    1              0.000002     let g:vimade_defaults.checkinterval = 1000
                            
                                ""@setting vimade.usecursorhold
                                "Supported:     lua, python
                                "Disables the timer running in the background and instead relies `OnCursorHold` and `updatetime` (see h:updatetime).  The default value is `0` except on older Windows GVIM, which defaults to `1` due to the timer breaking movements.  If you find that the timer is causing performance problems or other issues you can disable it by setting this option to `1`. 
                            
    1              0.000005     let g:vimade_defaults.usecursorhold = g:vimade_features.has_gui_running && !g:vimade_features.has_nvim && g:vimade_features.has_gui_version
                            
                                ""@setting vimade.basegroups
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting that specifies the basegroups/built-in highlight groups that will be faded using winhl when switching windows
                            
    1              0.000009     let g:vimade_defaults.basegroups = ['Folded', 'Search', 'SignColumn', 'CursorLine', 'CursorLineNr', 'DiffAdd', 'DiffChange', 'DiffDelete', 'DiffText', 'FoldColumn', 'Whitespace', 'NonText', 'SpecialKey', 'Conceal', 'EndOfBuffer', 'WinSeparator', 'LineNr', 'LineNrAbove', 'LineNrBelow']
                            
                                ""@setting vimade.enablebasegroups
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting.  Enabled by default and allows basegroups/built-in highlight fading using winhl.  This allows fading of built-in highlights such as Folded, Search, etc.
                            
    1              0.000002     let g:vimade_defaults.enablebasegroups = 1
                            
                            
                                ""@setting vimade.enabletreesitter
                                "Supported:     python
                                "lua uses namespaces and doesn't require this setting.
                                "Neovim only setting.  Disabled by default and hooks vimade into the internals of treesitter.
                            
    1              0.000002     let g:vimade_defaults.enabletreesitter = 0
                            
                                ""@setting vimade.enablesigns
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "Enabled by default for vim/nvim versions that support sign priority and causes signs to be faded when switching buffers.
                                "Only visible signs are faded. This feature can cause performance issues
                                "on older nvim/vim versions that don't support sign priority. 
                                "Use signsretentionperiod to control the duration that vimade checks for sign updates after switching buffers.
                            
    1              0.000003     let g:vimade_defaults.enablesigns = g:vimade_features.has_sign_priority
                            
                                ""@setting vimade.signsid
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "The starting id that Vimade should use when creating new signs. By
                                "default Vim requires numeric values to create signs and its possible that
                                "collisions may occur between plugins.  If you need to override this value for
                                "compatibility, please open an issue as well.  Default is 13100.
                            
    1              0.000002     let g:vimade_defaults.signsid = 13100
                            
                                ""@setting vimade.signsretentionperiod
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                " *python*: Serves no purpose on lua renderer.
                                "Amount of time in milliseconds that faded buffers should be tracked for sign changes.  Default value is 4000.
                            
    1              0.000002     let g:vimade_defaults.signsretentionperiod = 4000
                            
                                ""@setting vimade.signspriority
                                "Supported:     python
                                "lua renderer doesn't require additional logic to fade signs.
                                "Controls the signs fade priority.
                                "You may need to change this value if you find that not all signs are fading properly.
                                "Please also open a defect if you need to tweak this value as Vimade strives to minimize manual configuration where possible.
                                "Default is 31.
                            
    1              0.000002     let g:vimade_defaults.signspriority = 31
                            
                                ""@setting vimade.fademinimap
                                "Supported:     lua, python
                                "Enables fading for `severin-lemaignan/vim-minimap`. Setting vimade.fademinimap to
                                "0 disables the special fade.  Default is 1.
                            
    1              0.000002     let g:vimade_defaults.fademinimap = 1
                            
                                ""@setting vimade.fadepriority
                                "Supported:     python
                                "lua uses namespaces and doesn't require priority settings
                                "Controls the highlighting priority.
                                "You may want to tweak this value to make Vimade play nicely with other highlighting plugins and behaviors.
                                "For example, if you want hlsearch to show results on all buffers, you may want to lower this value to 0.
                                "Default is 10.
                            
    1              0.000002     let g:vimade_defaults.fadepriority = 10
                            
                                ""@setting vimade.disablebatch
                                "Supported:     python
                                "Disables interprocess batching. Useful if you are seeing issues and need to debug an error.
                            
    1              0.000002     let g:vimade_defaults.disablebatch = 0
                            
    1              0.000008     let g:vimade_defaults_keys = keys(g:vimade_defaults)
    1              0.000003     if exists('g:vimade_usecursorhold')
                                  let g:vimade.usecursorhold = g:vimade_usecursorhold
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001   return g:vimade_defaults

FUNCTION  vimade#StopTimer()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:789
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000006   if exists('g:vimade_timer')
    1              0.000006     call timer_stop(g:vimade_timer)
    1              0.000003     unlet g:vimade_timer
    2              0.000001   endif

FUNCTION  vimade#UpdateState()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:664
Called 1 time
Total time:   0.000249
 Self time:   0.000123

count  total (s)   self (s)
    1              0.000010   if !exists('g:vimade')
                                let g:vimade = {}
    1              0.000001   endif
    1              0.000003   if !has_key(g:vimade, '$extended')
                                call vimade#ExtendState()
    1              0.000000   endif
    1              0.000006   let l:recipe = get(g:vimade, 'recipe')
    1              0.000005   if l:recipe isnot g:vimade.__recipe
                                let g:vimade.__recipe = l:recipe
                                let g:__vimade_recipe_applied = 0
    1              0.000000   endif
    1   0.000022   0.000008   let normalid = vimade#GetMaybeFromOverlay('normalid')
    1              0.000003   if normalid == "" || normalid == 0 || normalid == v:null
    1              0.000006     let g:vimade.normalid = hlID('Normal')
    1              0.000000   endif
    1   0.000015   0.000006   let normalncid = vimade#GetMaybeFromOverlay('normalncid')
    1              0.000004   if g:vimade_features.has_nvim && (normalncid == "" || normalncid == 0 || normalncid == v:null)
    1              0.000003     let g:vimade.normalncid = hlID('NormalNC')
    1              0.000000   endif
    1   0.000013   0.000006   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
    1              0.000003   if usecursorhold != g:vimade_last.usecursorhold
                                let g:vimade_last.usecursorhold = usecursorhold
                                if usecursorhold
                                  call vimade#StopTimer()
                                else
                                  call vimade#StartTimer()
                                endif
                                call vimade#UpdateEvents()
    1              0.000001   endif
    1   0.000012   0.000006   let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
    1              0.000002   if checkinterval != g:vimade_last.checkinterval
                                let g:vimade_last.checkinterval = checkinterval
                                call vimade#StopTimer()
                                call vimade#StartTimer()
    1              0.000000   endif
    1              0.000005   let g:vimade.__background = &background
    1              0.000005   let g:vimade.__colorscheme = exists('g:colors_name') ? g:colors_name : ""
    1              0.000003   let g:vimade.__termguicolors = &termguicolors
    1   0.000098   0.000007   call vimade#SetupRenderer()

FUNCTION  vimade#Init()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:796
Called 1 time
Total time:   0.000881
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000003   let l:already_running = 0
    1              0.000004   if exists('g:vimade_init')
                                let l:already_running = 1
    1              0.000002   endif
    1              0.000002   let g:vimade_init = 1
    1   0.000044   0.000009   call vimade#CreateGlobals()
    1   0.000175   0.000031   call vimade#GetFeatures()
    1   0.000174   0.000010   call vimade#GetDefaults()
    1   0.000222   0.000007   call vimade#ExtendState()
    1   0.000102   0.000008   call vimade#UpdateEvents()
                            
    1              0.000023   let g:vimade_last = extend({}, g:vimade)
                            
                              "check immediately
    1              0.000007   if l:already_running == 0
    1   0.000032   0.000008     call vimade#DeferredCheckWindows()
                              else
                                call vimade#Redraw()
    1              0.000001   endif
    1   0.000053   0.000007   call vimade#StartTimer()
                            
                              "run the timer once during startup
                              "we use try here to possibly support vim 7
    1   0.000016   0.000008   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
    1              0.000001   if usecursorhold
                                let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
                                try
                                  call timer_start(checkinterval, 'vimade#Tick')
                                catch
                                endtry
    1              0.000001   endif

FUNCTION  vimade#CheckWindows()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:583
Called 1 time
Total time:   0.000267
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000255   0.000006   call vimade#UpdateState()
                              "prevent if inside popup window
                              " TODO: confirm if this is needed in newer renderers, which perform
                              " significantly better
    1              0.000003   if winnr() == 0 || pumvisible() 
                                return
    1              0.000000   endif
    1              0.000002   if g:vimade_running && g:vimade_paused == 0 && getcmdwintype() == ''
                                call g:vimade_active_renderer.update()
    1              0.000001   endif

FUNCTION  <SNR>13_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/syntax/synload.vim:27
Called 10 times
Total time:   0.016775
 Self time:   0.015859

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   10              0.000079   syn clear
   10              0.000035   if exists("b:current_syntax")
                                unlet b:current_syntax
   10              0.000007   endif
                            
   10              0.000046   0verbose let s = expand("<amatch>")
   10              0.000015   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   10              0.000009   elseif s == "OFF"
                                let s = ""
   10              0.000003   endif
                            
   10              0.000006   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    6              0.000026     for name in split(s, '\.')
    3              0.000005       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    3   0.016350   0.015434         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    3              0.000005       endif
    6              0.000005     endfor
   10              0.000004   endif

FUNCTION  vimade#Tick()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:706
Called 1 time
Total time:   0.000298
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003   try
    1   0.000275   0.000008     call vimade#CheckWindows()
                              catch
                                let g:vimade_error_count += 1
                                if g:vimade_error_count >= 3
                                  let g:vimade_error_count = 0
                                  try
                                    VimadeDisable
                                  catch
                                    let g:vimade_running = 0
                                  endtry
                                endif
                                throw 'Vimade Error='.g:vimade_error_count . '\n' . v:exception
    1              0.000000   endtry

FUNCTION  vimade#GetFeatures()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:85
Called 1 time
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    1              0.000006   if !exists('g:vimade_features')
    1              0.000003     let g:vimade_features = {}
    1              0.000012     let g:vimade_features.has_gui_running = has('gui_running')
    1              0.000004     let g:vimade_features.has_gui = has('gui')
    1              0.000004     let g:vimade_features.has_nvim = has('nvim')
    1              0.000004     let g:vimade_features.has_vimr = has('gui_vimr')
    1              0.000005     let g:vimade_features.has_timer_start = exists('*timer_start')
    1              0.000004     let g:vimade_features.has_sign_getplaced = exists('*sign_getplaced')
                            
    1              0.000003     if g:vimade_features.has_nvim
                                  " Below are for lua renderer
                            
                                  " Required:
                                  " Required: nvim_win_set_hl_ns
    1              0.000005       let g:vimade_features.has_nvim_win_set_hl_ns = exists('*nvim_win_set_hl_ns')
                                  " Required:
                                  " Either (preferred) nvim_get_hl
    1              0.000003       let g:vimade_features.has_nvim_get_hl = exists('*nvim_get_hl')
                                  " Or (fallback) nvim__get_hl_defs + nvim_get_hl_by_name (assume supported)
    1              0.000005       let g:vimade_features.has__nvim_get_hl_defs = exists('*nvim__get_hl_defs')
                                  
                                  "Optional:
                                  " preferred but not required nvim_get_hl_ns
                                  " fallback is try and manually track (probably will have conflicts with some plugins)
    1              0.000003       let g:vimade_features.has_nvim_get_hl_ns = exists('*nvim_get_hl_ns')
                            
    1              0.000006       let g:vimade_features.supports_lua_renderer = (g:vimade_features.has_nvim_get_hl || g:vimade_features.has__nvim_get_hl_defs) && g:vimade_features.has_nvim_win_set_hl_ns
    1              0.000002       let g:vimade_features.has_wincolor = 0
    1              0.000002       let g:vimade_features.has_gui_version = 0
                                else
                                  let g:vimade_features.has_nvim_win_set_hl_ns = 0
                                  let g:vimade_features.has_nvim_get_hl = 0
                                  let g:vimade_features.has__nvim_get_hl_defs = 0
                                  let g:vimade_features.has_nvim_get_hl_ns = 0
                                  let g:vimade_features.supports_lua_renderer = 0
                                  let g:vimade_features.has_wincolor = exists('&wincolor')
                                  let g:vimade_features.has_gui_version = execute('version')=~"GUI version"
    1              0.000001     endif
                            
    1              0.000002     try
    1              0.000008       sign define Vimade_Test text=1
    1              0.000016       sign place 1 group=vimade line=1 name=Vimade_Test priority=100
    1              0.000005       sign unplace 1 group=vimade
    1              0.000003       let g:vimade_features.has_sign_group = 1
    1              0.000003       let g:vimade_features.has_sign_priority = 1
                                catch
                                  let g:vimade_features.has_sign_group = 0
                                  let g:vimade_features.has_sign_priority = 0
    1              0.000002     endtry
    1              0.000001   endif
    1              0.000003   return g:vimade_features

FUNCTION  vimade#Empty()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:6
Called 2 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  <SNR>27_set_pbcopy()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/autoload/provider/clipboard.vim:70
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   let s:copy['+'] = ['pbcopy']
    1              0.000001   let s:paste['+'] = ['pbpaste']
    1              0.000003   let s:copy['*'] = s:copy['+']
    1              0.000001   let s:paste['*'] = s:paste['+']
    1              0.000001   let s:cache_enabled = 0
    1              0.000001   return 'pbcopy'

FUNCTION  vimade#SetupRenderer()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:30
Called 1 time
Total time:   0.000091
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000003   let l:next_renderer = g:vimade_active_renderer.name
    1              0.000004   if (g:vimade.renderer == 'auto' && g:vimade_features.supports_lua_renderer) || g:vimade.renderer == 'lua'
    1              0.000001     let l:next_renderer = 'lua'
                              else
                                if g:vimade_python_setup == 0
                                  call vimade#SetupPython()
                                endif
                                if g:vimade.renderer == 'auto'
                                  let l:next_renderer = 'python'
                                elseif g:vimade.renderer == 'python'
                                  let l:next_renderer = g:vimade.renderer
                                endif
    1              0.000000   endif
    1              0.000002   if l:next_renderer != g:vimade_active_renderer.name
    1              0.000000     try
    1   0.000053   0.000025       call vimade#UnhighlightAll()
                                catch
    1              0.000002     endtry
    1              0.000002     if l:next_renderer == 'lua'
    1              0.000003       let g:vimade_active_renderer = s:lua_renderer
                                elseif l:next_renderer == 'python'
                                  let g:vimade_active_renderer = s:python_renderer
                                else
                                  let g:vimade_active_renderer = s:empty_renderer
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  vimade#StartTimer()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:781
Called 1 time
Total time:   0.000046
 Self time:   0.000028

count  total (s)   self (s)
                              "timer is disabled when usecursorhold=1
    1   0.000017   0.000008   let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
    1              0.000004   if !usecursorhold && !exists('g:vimade_timer') && g:vimade_running
    1   0.000016   0.000008     let checkinterval = vimade#GetMaybeFromOverlay('checkinterval')
    1              0.000006     let g:vimade_timer = timer_start(checkinterval, 'vimade#Tick', {'repeat': -1})
    1              0.000001   endif

FUNCTION  vimade#Load()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:2
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                              " empty hook to initiate loading

FUNCTION  vimade#UnhighlightAll()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:412
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000005   if winnr() == 0
                                return
    1              0.000000   endif
    1   0.000019   0.000019   call g:vimade_active_renderer.disable()

FUNCTION  vimade#DeferredCheckWindows()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:565
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000012   if g:vimade_features.has_timer_start
                                " only disable the deferred on animation for lua (lua doesn't
                                " only_these_windows)
    3              0.000015     if exists('g:vimade_deferred_timer') || (exists('g:vimade_animation_running') && g:vimade_active_renderer == s:lua_renderer)
    2              0.000005       return
    1              0.000001     endif
    1              0.000007     let g:vimade_deferred_timer = timer_start(1, 'vimade#DeferredTick')
                              else
                                return vimade#CheckWindows()
    1              0.000001   endif

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/indent.vim:14
Called 78 times
Total time:   0.033344
 Self time:   0.033156

count  total (s)   self (s)
   78              0.000213     if exists("b:undo_indent")
    1              0.000013       exe b:undo_indent
    1              0.000003       unlet! b:undo_indent b:did_indent
   78              0.000024     endif
   78              0.000226     let s = expand("<amatch>")
   78              0.000081     if s != ""
   78              0.000066       if exists("b:did_indent")
                            	unlet b:did_indent
   78              0.000024       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
  156              0.000256       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   78   0.031729   0.031540         exe $'runtime! indent/{name}[.]{{vim,lua}}'
  156              0.000209       endfor
   78              0.000023     endif

FUNCTION  <SNR>26_Disable_Lua()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:857
Called 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000082   lua require('vimade').disable()

FUNCTION  vimade#GetMaybeFromOverlay()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:656
Called 8 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    8              0.000027   if exists('g:vimade_overlay.' .. a:field)
                                return get(g:vimade_overlay, a:field)
    8              0.000005   else
    8              0.000019     return get(g:vimade, a:field)
                              endif

FUNCTION  <SNR>9_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/plugin/matchparen.vim:203
Called 106 times
Total time:   0.000861
 Self time:   0.000861

count  total (s)   self (s)
  106              0.000192   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
  106              0.000026   endif

FUNCTION  vimade#ExtendState()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:648
Called 1 time
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
   24              0.000027   for prop in g:vimade_defaults_keys
   23              0.000049     if !has_key(g:vimade, prop)
   23              0.000067       let g:vimade[prop] = g:vimade_defaults[prop]
   23              0.000011     endif
   24              0.000043   endfor

FUNCTION  vimade#UpdateEvents()
    Defined: ~/.local/share/nvim/lazy/plugins/vimade/autoload/vimade.vim:627
Called 1 time
Total time:   0.000094
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000004   augroup vimade
    1              0.000018       au!
    1              0.000010       au VimLeave * call vimade#Disable()
    1              0.000004       au FocusGained * call vimade#FocusGained()
    1              0.000009       au FocusLost * call vimade#FocusLost()
                                  " TODO neovim is broken in many scenarios in v0.10. Python logic is not
                                  " executed properly when called directly off and autoevent. This is
                                  " easily reproduceable when using netrw...
    1              0.000005       au WinEnter,BufEnter * call vimade#DeferredCheckWindows()
    1              0.000006       au OptionSet diff call vimade#DeferredCheckWindows()
    1              0.000003       au ColorScheme * call vimade#Redraw()
    1              0.000004       au FileChangedShellPost * call vimade#softInvalidateBuffer(expand("<abuf>"))
    1   0.000023   0.000011       let usecursorhold = vimade#GetMaybeFromOverlay('usecursorhold')
    1              0.000002       if usecursorhold
                                    au CursorHold,CursorHoldI * call vimade#DeferredCheckWindows()
                                    au VimResized * call vimade#DeferredCheckWindows()
    1              0.000001       endif
    1              0.000001   augroup END

FUNCTION  provider#clipboard#Executable()
    Defined: /opt/homebrew/Cellar/neovim/HEAD-e2bc84e_1/share/nvim/runtime/autoload/provider/clipboard.vim:184
Called 1 time
Total time:   0.000075
 Self time:   0.000063

count  total (s)   self (s)
                              " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
    1              0.000005   if exists('g:clipboard') && g:clipboard isnot# v:false
                                if v:t_string ==# type(g:clipboard)
                                  " Handle string form of g:clipboard for all builtin providers
                                  if 'osc52' == g:clipboard
                                    " User opted-in to OSC 52 by manually setting g:clipboard.
                                    return s:set_osc52()
                                  elseif 'pbcopy' == g:clipboard
                                    return s:set_pbcopy()
                                  elseif 'wl-copy' == g:clipboard
                                    return s:set_wayland()
                                  elseif 'wayclip' == g:clipboard
                                    return s:set_wayclip()
                                  elseif 'xsel' == g:clipboard
                                    return s:set_xsel()
                                  elseif 'xclip' == g:clipboard
                                    return s:set_xclip()
                                  elseif 'lemonade' == g:clipboard
                                    return s:set_lemonade()
                                  elseif 'doitclient' == g:clipboard
                                    return s:set_doitclient()
                                  elseif 'win32yank' == g:clipboard
                                    return s:set_win32yank()
                                  elseif 'putclip' == g:clipboard
                                    return s:set_putclip()
                                  elseif 'clip' == g:clipboard
                                    return s:set_clip()
                                  elseif 'termux' == g:clipboard
                                    return s:set_termux()
                                  elseif 'tmux' == g:clipboard
                                    return s:set_tmux()
                                  endif
                                endif
                            
                                if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
                                  let s:err = 'clipboard: invalid g:clipboard'
                                  return ''
                                endif
                            
                                let s:copy = {}
                                let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
                                let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
                            
                                let s:paste = {}
                                let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
                                let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
                            
                                let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
                                return get(g:clipboard, 'name', 'g:clipboard')
    1              0.000005   elseif has('mac')
    1   0.000019   0.000006     return s:set_pbcopy()
                              elseif !empty($WAYLAND_DISPLAY) && executable('wl-copy') && executable('wl-paste')
                                return s:set_wayland()
                              elseif !empty($WAYLAND_DISPLAY) && executable('waycopy') && executable('waypaste')
                                return s:set_wayclip()
                              elseif !empty($DISPLAY) && executable('xsel') && s:cmd_ok('xsel -o -b')
                                return s:set_xsel()
                              elseif !empty($DISPLAY) && executable('xclip')
                                return s:set_xclip()
                              elseif executable('lemonade')
                                return s:set_lemonade()
                              elseif executable('doitclient')
                                return s:set_doitclient()
                              elseif executable('win32yank.exe')
                                return s:set_win32yank()
                              elseif executable('putclip') && executable('getclip')
                                return s:set_putclip()
                              elseif executable('clip') && executable('powershell')
                                return s:set_clip()
                              elseif executable('termux-clipboard-set')
                                return s:set_termux()
                              elseif !empty($TMUX) && executable('tmux')
                                return s:set_tmux()
                              elseif get(get(g:, 'termfeatures', {}), 'osc52') && &clipboard ==# ''
                                " Don't use OSC 52 when 'clipboard' is set. It can be slow and cause a lot
                                " of user prompts. Users can opt-in to it by setting g:clipboard manually.
                                return s:set_osc52()
                              endif
                            
                              let s:err = 'clipboard: No clipboard tool. :help clipboard'
                              return ''

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   78   0.240040   0.158544  <SNR>1_LoadFTPlugin()
   78   0.033344   0.033156  <SNR>2_LoadIndent()
   10   0.016775   0.015859  <SNR>13_SynSet()
  104   0.005456   0.004653  <SNR>9_Highlight_Matching_Pair()
    1   0.000881   0.000151  vimade#Init()
  106   0.000861             <SNR>9_Remove_Matches()
    1   0.000334   0.000036  vimade#DeferredTick()
    1   0.000298   0.000031  vimade#Tick()
    1   0.000267   0.000018  vimade#CheckWindows()
    1   0.000249   0.000123  vimade#UpdateState()
    1   0.000215             vimade#ExtendState()
    2   0.000166   0.000061  vimade#Disable()
    1   0.000164             vimade#GetDefaults()
    1   0.000144             vimade#GetFeatures()
    1   0.000094   0.000082  vimade#UpdateEvents()
    1   0.000091   0.000064  vimade#SetupRenderer()
    1   0.000082             <SNR>26_Disable_Lua()
    1   0.000075   0.000063  provider#clipboard#Executable()
    8   0.000074             vimade#GetMaybeFromOverlay()
    3   0.000055             vimade#DeferredCheckWindows()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   78   0.240040   0.158544  <SNR>1_LoadFTPlugin()
   78   0.033344   0.033156  <SNR>2_LoadIndent()
   10   0.016775   0.015859  <SNR>13_SynSet()
  104   0.005456   0.004653  <SNR>9_Highlight_Matching_Pair()
  106              0.000861  <SNR>9_Remove_Matches()
    1              0.000215  vimade#ExtendState()
    1              0.000164  vimade#GetDefaults()
    1   0.000881   0.000151  vimade#Init()
    1              0.000144  vimade#GetFeatures()
    1   0.000249   0.000123  vimade#UpdateState()
    1              0.000082  <SNR>26_Disable_Lua()
    1   0.000094   0.000082  vimade#UpdateEvents()
    8              0.000074  vimade#GetMaybeFromOverlay()
    1   0.000091   0.000064  vimade#SetupRenderer()
    1   0.000075   0.000063  provider#clipboard#Executable()
    2   0.000166   0.000061  vimade#Disable()
    3              0.000055  vimade#DeferredCheckWindows()
    1   0.000334   0.000036  vimade#DeferredTick()
    1              0.000035  vimade#CreateGlobals()
    1   0.000298   0.000031  vimade#Tick()

